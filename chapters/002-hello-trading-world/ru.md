# День 2: Hello, Trading World! — Первая программа

## Аналогия из трейдинга

Когда трейдер впервые открывает торговый терминал, он обычно делает тестовую сделку — покупает минимальный лот, чтобы убедиться, что всё работает. Это не ради прибыли, а чтобы понять механику.

Наша первая программа — это такая же "тестовая сделка". Мы напишем простейший код, чтобы понять, как работает Rust.

## Анатомия программы на Rust

Вот простейшая программа:

```rust
fn main() {
    println!("Hello, Trading World!");
}
```

Разберём каждую часть:

### `fn main()`

```rust
fn main() {
```

- `fn` — сокращение от "function" (функция)
- `main` — имя функции
- `()` — пустые скобки означают "нет входных параметров"
- `{` — начало тела функции

**Аналогия:** `main` — это как кнопка "Старт" в торговом боте. Когда ты запускаешь программу, Rust ищет функцию `main` и начинает выполнение с неё.

### `println!`

```rust
    println!("Hello, Trading World!");
```

- `println!` — это макрос (заметь `!` в конце), который выводит текст на экран
- Текст в кавычках — это строка, которую мы выводим
- `;` — точка с запятой заканчивает инструкцию

**Аналогия:** `println!` — это как лог в торговом терминале. Ты видишь сообщение о том, что произошло.

### Закрывающая скобка

```rust
}
```

Закрывает тело функции.

## Создание проекта

Вместо ручной компиляции используем Cargo — это удобнее:

```bash
cargo new trading_hello
cd trading_hello
```

Cargo создаст структуру:
```
trading_hello/
├── Cargo.toml    # Настройки проекта
└── src/
    └── main.rs   # Наш код
```

Открой `src/main.rs` — там уже есть Hello World!

## Запуск

```bash
cargo run
```

Ты увидишь:
```
   Compiling trading_hello v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `target/debug/trading_hello`
Hello, world!
```

## Модифицируем программу

Давай сделаем её более "торговой":

```rust
fn main() {
    println!("=== Торговый бот запущен ===");
    println!("Подключение к бирже...");
    println!("Готов к торговле!");
    println!("BTC/USDT: $42,000");
}
```

Запусти снова:
```bash
cargo run
```

## Форматированный вывод

`println!` умеет подставлять значения:

```rust
fn main() {
    println!("Цена BTC: {} USD", 42000);
    println!("Цена ETH: {} USD", 2500);
    println!("Прибыль: {}%", 15.5);
}
```

`{}` — это плейсхолдер, куда подставляется значение.

**Аналогия:** Это как шаблон сообщения в боте: "Куплено {} BTC по цене {} USDT".

## Несколько плейсхолдеров

```rust
fn main() {
    println!("Куплено {} {} по цене {} USDT", 0.5, "BTC", 42000);
}
```

Вывод: `Куплено 0.5 BTC по цене 42000 USDT`

## Именованные плейсхолдеры

```rust
fn main() {
    println!(
        "{symbol}: купил {amount} по {price}",
        symbol = "BTC/USDT",
        amount = 0.5,
        price = 42000
    );
}
```

Это удобнее читать!

## Специальные символы

```rust
fn main() {
    println!("Строка 1\nСтрока 2");  // \n — перенос строки
    println!("Цена:\t42000");         // \t — табуляция
    println!("Он сказал: \"Покупай!\""); // \" — кавычки внутри строки
}
```

## Практический пример

```rust
fn main() {
    println!("╔════════════════════════════╗");
    println!("║     TRADING BOT v0.1       ║");
    println!("╠════════════════════════════╣");
    println!("║ Баланс: {} USDT         ║", 10000);
    println!("║ Открытых позиций: {}       ║", 0);
    println!("║ Прибыль за день: {}%     ║", 0.0);
    println!("╚════════════════════════════╝");
}
```

## Что мы узнали

| Концепция | Описание |
|-----------|----------|
| `fn main()` | Точка входа — программа начинается здесь |
| `println!` | Вывод текста на экран |
| `{}` | Плейсхолдер для значений |
| `;` | Конец инструкции |
| `cargo run` | Компилирует и запускает проект |

## Домашнее задание

1. Создай новый проект `my_trading_bot` с помощью `cargo new`
2. Напиши программу, которая выводит:
   - Название твоего бота
   - Список из 3 криптовалют, которые ты "торгуешь"
   - Стартовый баланс
3. Используй форматированный вывод с `{}`

## Навигация

[← Предыдущий день](../001-installing-rust/ru.md) | [Следующий день →](../003-cargo-project-manager/ru.md)
