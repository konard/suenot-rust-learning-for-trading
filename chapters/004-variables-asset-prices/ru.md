# День 4: Переменные — храним цену актива

## Аналогия из трейдинга

Когда ты торгуешь, тебе нужно запоминать информацию:
- Цена входа в сделку
- Количество купленных монет
- Текущий баланс

В программировании для этого используются **переменные** — это как ячейки памяти с именами, куда мы записываем данные.

**Переменная = подписанный конверт с деньгами внутри**

## Объявление переменных

В Rust переменные создаются с помощью `let`:

```rust
fn main() {
    let btc_price = 42000;
    println!("Цена BTC: {} USD", btc_price);
}
```

Разберём:
- `let` — ключевое слово "создать переменную"
- `btc_price` — имя переменной (наш "конверт")
- `=` — присваиваем значение
- `42000` — значение внутри

## Правила именования

```rust
fn main() {
    // Хорошие имена (snake_case)
    let bitcoin_price = 42000;
    let entry_price = 41500;
    let position_size = 0.5;

    // Плохие имена
    // let 1price = 100;  // нельзя начинать с цифры
    // let my-price = 100; // нельзя использовать дефис
}
```

В Rust принято использовать `snake_case`: слова_через_подчёркивание.

**Аналогия:** Это как тикеры на бирже — короткие, понятные названия. `BTC` лучше, чем `Bitcoin_Cryptocurrency_Token_v2`.

## Неиспользуемые переменные

Если переменная не используется, Rust предупредит:

```rust
fn main() {
    let unused_variable = 100;  // Warning: unused variable
}
```

Чтобы сказать Rust "я знаю, что не использую", добавь `_`:

```rust
fn main() {
    let _unused_variable = 100;  // Предупреждения нет
}
```

## Несколько переменных

```rust
fn main() {
    let symbol = "BTC/USDT";
    let entry_price = 42000.0;
    let current_price = 43500.0;
    let quantity = 0.5;

    println!("Тикер: {}", symbol);
    println!("Цена входа: {}", entry_price);
    println!("Текущая цена: {}", current_price);
    println!("Количество: {}", quantity);
}
```

## Вывод типа

Rust умный — он сам понимает тип переменной:

```rust
fn main() {
    let price = 42000;      // Rust понимает: это целое число
    let amount = 0.5;       // Rust понимает: это дробное число
    let symbol = "BTC";     // Rust понимает: это строка
    let is_long = true;     // Rust понимает: это булево значение
}
```

## Явное указание типа

Иногда нужно указать тип явно:

```rust
fn main() {
    let price: f64 = 42000.0;    // 64-битное дробное число
    let quantity: f32 = 0.5;     // 32-битное дробное число
    let shares: i32 = 100;       // 32-битное целое со знаком
    let volume: u64 = 1000000;   // 64-битное целое без знака
}
```

**Аналогия:**
- `f64` — большой сейф для точных сумм (цены BTC с 8 знаками после запятой)
- `f32` — маленький сейф, занимает меньше места
- `i32` — сейф для чисел, включая отрицательные (прибыль/убыток)
- `u64` — огромный сейф только для положительных чисел (объём торгов)

## Переменные в выражениях

```rust
fn main() {
    let entry_price = 42000.0;
    let exit_price = 43500.0;
    let quantity = 0.5;

    let profit = (exit_price - entry_price) * quantity;

    println!("Прибыль: {} USDT", profit);
}
```

## Использование переменных несколько раз

```rust
fn main() {
    let btc_price = 42000.0;

    println!("Цена BTC: {}", btc_price);
    println!("Цена 2 BTC: {}", btc_price * 2.0);
    println!("Цена 0.5 BTC: {}", btc_price * 0.5);

    // btc_price всё ещё 42000.0 — мы его не меняли!
}
```

## Практический пример: калькулятор позиции

```rust
fn main() {
    // Входные данные
    let balance = 10000.0;          // Баланс в USDT
    let risk_percent = 2.0;         // Риск на сделку (%)
    let entry_price = 42000.0;      // Цена входа
    let stop_loss = 41000.0;        // Стоп-лосс

    // Расчёты
    let risk_amount = balance * (risk_percent / 100.0);
    let price_difference = entry_price - stop_loss;
    let position_size = risk_amount / price_difference;

    // Вывод
    println!("=== Калькулятор позиции ===");
    println!("Баланс: {} USDT", balance);
    println!("Риск: {}% = {} USDT", risk_percent, risk_amount);
    println!("Размер позиции: {} BTC", position_size);
    println!("Стоимость: {} USDT", position_size * entry_price);
}
```

Вывод:
```
=== Калькулятор позиции ===
Баланс: 10000 USDT
Риск: 2% = 200 USDT
Размер позиции: 0.2 BTC
Стоимость: 8400 USDT
```

## Что мы узнали

| Концепция | Пример | Описание |
|-----------|--------|----------|
| let | `let price = 42000;` | Создать переменную |
| snake_case | `entry_price` | Стиль именования |
| Вывод типа | `let x = 5;` | Rust сам определяет тип |
| Явный тип | `let x: f64 = 5.0;` | Мы указываем тип |
| `_` | `let _unused = 0;` | Игнорировать предупреждение |

## Домашнее задание

1. Создай переменные для хранения:
   - Название криптовалюты (строка)
   - Цена покупки (дробное число)
   - Количество монет (дробное число)
   - Дата покупки (строка)

2. Рассчитай и выведи:
   - Общую стоимость покупки
   - Стоимость при росте на 10%
   - Стоимость при падении на 10%

3. Поэкспериментируй с типами: попробуй использовать `f32` вместо `f64`

## Навигация

[← Предыдущий день](../003-cargo-project-manager/ru.md) | [Следующий день →](../005-immutability-locked-price/ru.md)
