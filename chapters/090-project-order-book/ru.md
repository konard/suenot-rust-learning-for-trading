# –î–µ–Ω—å 90: –ü—Ä–æ–µ–∫—Ç ‚Äî Order Book (–ö–Ω–∏–≥–∞ –∑–∞—è–≤–æ–∫)

## –í–≤–µ–¥–µ–Ω–∏–µ

–≠—Ç–æ **–ø—Ä–æ–µ–∫—Ç–Ω–∞—è –≥–ª–∞–≤–∞**, –∫–æ—Ç–æ—Ä–∞—è –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –∑–Ω–∞–Ω–∏—è –∑–∞ –º–µ—Å—è—Ü –≤ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –º–∏–Ω–∏-–ø—Ä–æ–µ–∫—Ç. –ú—ã —Å–æ–∑–¥–∞–¥–∏–º –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é **Order Book** ‚Äî –æ–¥–Ω–æ–π –∏–∑ –∫–ª—é—á–µ–≤—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –≤ –∞–ª–≥–æ—Ç—Ä–µ–π–¥–∏–Ω–≥–µ.

## –ß—Ç–æ —Ç–∞–∫–æ–µ Order Book?

**Order Book (–∫–Ω–∏–≥–∞ –∑–∞—è–≤–æ–∫)** ‚Äî —ç—Ç–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä–∞—è —Ö—Ä–∞–Ω–∏—Ç –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É –∏ –ø—Ä–æ–¥–∞–∂—É –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞.

```
         ASKS (–∑–∞—è–≤–∫–∏ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É)
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ $42,150  ‚îÇ  2.5 BTC    ‚îÇ ‚Üê –õ—É—á—à–∏–π ask (lowest)
         ‚îÇ $42,200  ‚îÇ  1.8 BTC    ‚îÇ
         ‚îÇ $42,300  ‚îÇ  3.2 BTC    ‚îÇ
         ‚îÇ $42,500  ‚îÇ  5.0 BTC    ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   SPREAD
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ $42,100  ‚îÇ  1.5 BTC    ‚îÇ ‚Üê –õ—É—á—à–∏–π bid (highest)
         ‚îÇ $42,050  ‚îÇ  2.0 BTC    ‚îÇ
         ‚îÇ $42,000  ‚îÇ  4.2 BTC    ‚îÇ
         ‚îÇ $41,900  ‚îÇ  3.8 BTC    ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         BIDS (–∑–∞—è–≤–∫–∏ –Ω–∞ –ø–æ–∫—É–ø–∫—É)
```

### –ö–ª—é—á–µ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏

- **Bid** ‚Äî –∑–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É (–ø–æ–∫—É–ø–∞—Ç–µ–ª—å –≥–æ—Ç–æ–≤ –∫—É–ø–∏—Ç—å –ø–æ —ç—Ç–æ–π —Ü–µ–Ω–µ)
- **Ask** ‚Äî –∑–∞—è–≤–∫–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É (–ø—Ä–æ–¥–∞–≤–µ—Ü –≥–æ—Ç–æ–≤ –ø—Ä–æ–¥–∞—Ç—å –ø–æ —ç—Ç–æ–π —Ü–µ–Ω–µ)
- **Spread** ‚Äî —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –ª—É—á—à–∏–º ask –∏ –ª—É—á—à–∏–º bid
- **Depth** ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Ä–æ–≤–Ω–µ–π —Ü–µ–Ω –≤ —Å—Ç–∞–∫–∞–Ω–µ
- **Liquidity** ‚Äî –æ–±—â–∏–π –æ–±—ä—ë–º –Ω–∞ –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω–µ —Å—Ç–∞–∫–∞–Ω–∞

## –ß–∞—Å—Ç—å 1: –ë–∞–∑–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ Order

–ù–∞—á–Ω—ë–º —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞:

```rust
use std::cmp::Ordering;

/// –°—Ç–æ—Ä–æ–Ω–∞ –æ—Ä–¥–µ—Ä–∞
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Side {
    Bid,  // –ü–æ–∫—É–ø–∫–∞
    Ask,  // –ü—Ä–æ–¥–∞–∂–∞
}

/// –û—Ç–¥–µ–ª—å–Ω—ã–π –æ—Ä–¥–µ—Ä –≤ –∫–Ω–∏–≥–µ –∑–∞—è–≤–æ–∫
#[derive(Debug, Clone)]
pub struct Order {
    pub id: u64,
    pub price: f64,
    pub quantity: f64,
    pub side: Side,
    pub timestamp: u64,
}

impl Order {
    pub fn new(id: u64, price: f64, quantity: f64, side: Side, timestamp: u64) -> Self {
        Order {
            id,
            price,
            quantity,
            side,
            timestamp,
        }
    }

    /// –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ä–¥–µ—Ä–∞
    pub fn total_value(&self) -> f64 {
        self.price * self.quantity
    }
}

fn main() {
    let bid = Order::new(1, 42100.0, 1.5, Side::Bid, 1000);
    let ask = Order::new(2, 42150.0, 2.0, Side::Ask, 1001);

    println!("Bid: {:?}", bid);
    println!("Ask: {:?}", ask);
    println!("Bid value: ${:.2}", bid.total_value());
}
```

## –ß–∞—Å—Ç—å 2: –£—Ä–æ–≤–µ–Ω—å —Ü–µ–Ω—ã (Price Level)

–ì—Ä—É–ø–ø–∏—Ä—É–µ–º –æ—Ä–¥–µ—Ä–∞ –ø–æ —É—Ä–æ–≤–Ω—è–º —Ü–µ–Ω:

```rust
use std::collections::VecDeque;

/// –£—Ä–æ–≤–µ–Ω—å —Ü–µ–Ω—ã ‚Äî –≤—Å–µ –æ—Ä–¥–µ—Ä–∞ –ø–æ –æ–¥–Ω–æ–π —Ü–µ–Ω–µ
#[derive(Debug, Clone)]
pub struct PriceLevel {
    pub price: f64,
    pub orders: VecDeque<Order>,
}

impl PriceLevel {
    pub fn new(price: f64) -> Self {
        PriceLevel {
            price,
            orders: VecDeque::new(),
        }
    }

    /// –î–æ–±–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä –Ω–∞ —É—Ä–æ–≤–µ–Ω—å
    pub fn add_order(&mut self, order: Order) {
        self.orders.push_back(order);
    }

    /// –û–±—â–∏–π –æ–±—ä—ë–º –Ω–∞ —É—Ä–æ–≤–Ω–µ
    pub fn total_quantity(&self) -> f64 {
        self.orders.iter().map(|o| o.quantity).sum()
    }

    /// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ä–¥–µ—Ä–æ–≤ –Ω–∞ —É—Ä–æ–≤–Ω–µ
    pub fn order_count(&self) -> usize {
        self.orders.len()
    }

    /// –£–±—Ä–∞—Ç—å –æ—Ä–¥–µ—Ä –ø–æ ID
    pub fn remove_order(&mut self, order_id: u64) -> Option<Order> {
        if let Some(pos) = self.orders.iter().position(|o| o.id == order_id) {
            self.orders.remove(pos)
        } else {
            None
        }
    }
}

fn main() {
    let mut level = PriceLevel::new(42100.0);

    level.add_order(Order::new(1, 42100.0, 1.5, Side::Bid, 1000));
    level.add_order(Order::new(2, 42100.0, 2.0, Side::Bid, 1001));
    level.add_order(Order::new(3, 42100.0, 0.8, Side::Bid, 1002));

    println!("Price level: ${}", level.price);
    println!("Total quantity: {} BTC", level.total_quantity());
    println!("Order count: {}", level.order_count());
}
```

## –ß–∞—Å—Ç—å 3: –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è Order Book

```rust
use std::collections::{BTreeMap, VecDeque};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Side {
    Bid,
    Ask,
}

#[derive(Debug, Clone)]
pub struct Order {
    pub id: u64,
    pub price: f64,
    pub quantity: f64,
    pub side: Side,
    pub timestamp: u64,
}

impl Order {
    pub fn new(id: u64, price: f64, quantity: f64, side: Side, timestamp: u64) -> Self {
        Order { id, price, quantity, side, timestamp }
    }
}

#[derive(Debug, Clone)]
pub struct PriceLevel {
    pub price: f64,
    pub orders: VecDeque<Order>,
}

impl PriceLevel {
    pub fn new(price: f64) -> Self {
        PriceLevel { price, orders: VecDeque::new() }
    }

    pub fn add_order(&mut self, order: Order) {
        self.orders.push_back(order);
    }

    pub fn total_quantity(&self) -> f64 {
        self.orders.iter().map(|o| o.quantity).sum()
    }

    pub fn is_empty(&self) -> bool {
        self.orders.is_empty()
    }
}

/// –ü–æ–ª–Ω–∞—è –∫–Ω–∏–≥–∞ –∑–∞—è–≤–æ–∫
#[derive(Debug)]
pub struct OrderBook {
    pub symbol: String,
    // Bids: –∫–ª—é—á = price * -1 –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
    bids: BTreeMap<i64, PriceLevel>,
    // Asks: –∫–ª—é—á = price (–ø—Ä—è–º–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞)
    asks: BTreeMap<i64, PriceLevel>,
    next_order_id: u64,
    price_precision: u32,
}

impl OrderBook {
    pub fn new(symbol: &str, price_precision: u32) -> Self {
        OrderBook {
            symbol: symbol.to_string(),
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            next_order_id: 1,
            price_precision,
        }
    }

    /// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Ü–µ–Ω—ã –≤ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –∫–ª—é—á
    fn price_to_key(&self, price: f64) -> i64 {
        (price * 10_f64.powi(self.price_precision as i32)) as i64
    }

    /// –î–æ–±–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä –≤ –∫–Ω–∏–≥—É
    pub fn add_order(&mut self, price: f64, quantity: f64, side: Side) -> u64 {
        let order_id = self.next_order_id;
        self.next_order_id += 1;

        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;

        let order = Order::new(order_id, price, quantity, side, timestamp);

        match side {
            Side::Bid => {
                let key = -self.price_to_key(price); // –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
                self.bids
                    .entry(key)
                    .or_insert_with(|| PriceLevel::new(price))
                    .add_order(order);
            }
            Side::Ask => {
                let key = self.price_to_key(price);
                self.asks
                    .entry(key)
                    .or_insert_with(|| PriceLevel::new(price))
                    .add_order(order);
            }
        }

        order_id
    }

    /// –õ—É—á—à–∏–π bid (—Å–∞–º–∞—è –≤—ã—Å–æ–∫–∞—è —Ü–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏)
    pub fn best_bid(&self) -> Option<(f64, f64)> {
        self.bids.values().next().map(|level| {
            (level.price, level.total_quantity())
        })
    }

    /// –õ—É—á—à–∏–π ask (—Å–∞–º–∞—è –Ω–∏–∑–∫–∞—è —Ü–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏)
    pub fn best_ask(&self) -> Option<(f64, f64)> {
        self.asks.values().next().map(|level| {
            (level.price, level.total_quantity())
        })
    }

    /// –°–ø—Ä–µ–¥ (—Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –ª—É—á—à–∏–º ask –∏ bid)
    pub fn spread(&self) -> Option<f64> {
        match (self.best_bid(), self.best_ask()) {
            (Some((bid, _)), Some((ask, _))) => Some(ask - bid),
            _ => None,
        }
    }

    /// –ü—Ä–æ—Ü–µ–Ω—Ç–Ω—ã–π —Å–ø—Ä–µ–¥
    pub fn spread_percent(&self) -> Option<f64> {
        match (self.best_bid(), self.best_ask()) {
            (Some((bid, _)), Some((ask, _))) => {
                let mid_price = (bid + ask) / 2.0;
                Some((ask - bid) / mid_price * 100.0)
            }
            _ => None,
        }
    }

    /// –°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ (mid price)
    pub fn mid_price(&self) -> Option<f64> {
        match (self.best_bid(), self.best_ask()) {
            (Some((bid, _)), Some((ask, _))) => Some((bid + ask) / 2.0),
            _ => None,
        }
    }

    /// –ü–æ–ª—É—á–∏—Ç—å N –ª—É—á—à–∏—Ö —É—Ä–æ–≤–Ω–µ–π bids
    pub fn top_bids(&self, n: usize) -> Vec<(f64, f64)> {
        self.bids
            .values()
            .take(n)
            .map(|level| (level.price, level.total_quantity()))
            .collect()
    }

    /// –ü–æ–ª—É—á–∏—Ç—å N –ª—É—á—à–∏—Ö —É—Ä–æ–≤–Ω–µ–π asks
    pub fn top_asks(&self, n: usize) -> Vec<(f64, f64)> {
        self.asks
            .values()
            .take(n)
            .map(|level| (level.price, level.total_quantity()))
            .collect()
    }

    /// –û–±—â–∏–π –æ–±—ä—ë–º –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ bid
    pub fn total_bid_volume(&self) -> f64 {
        self.bids.values().map(|l| l.total_quantity()).sum()
    }

    /// –û–±—â–∏–π –æ–±—ä—ë–º –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ ask
    pub fn total_ask_volume(&self) -> f64 {
        self.asks.values().map(|l| l.total_quantity()).sum()
    }

    /// –î–∏—Å–±–∞–ª–∞–Ω—Å –æ—Ä–¥–µ—Ä–æ–≤ (–æ—Ç–Ω–æ—à–µ–Ω–∏–µ bid –∫ ask)
    pub fn order_imbalance(&self) -> f64 {
        let bid_vol = self.total_bid_volume();
        let ask_vol = self.total_ask_volume();

        if ask_vol == 0.0 {
            return if bid_vol > 0.0 { 1.0 } else { 0.0 };
        }

        bid_vol / (bid_vol + ask_vol)
    }

    /// –ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ –∫–Ω–∏–≥–∏ –∑–∞—è–≤–æ–∫
    pub fn display(&self, depth: usize) {
        println!("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        println!("‚ïë         ORDER BOOK: {}               ‚ïë", self.symbol);
        println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");

        // Asks (–≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è)
        let asks: Vec<_> = self.top_asks(depth);
        println!("‚ïë              ASKS (Sell)                 ‚ïë");
        println!("‚ïë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïë");
        for (price, qty) in asks.iter().rev() {
            println!("‚ïë   {:>10.2}  ‚îÇ  {:>10.4}               ‚ïë", price, qty);
        }

        // –°–ø—Ä–µ–¥
        println!("‚ïë‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïë");
        if let Some(spread) = self.spread() {
            println!("‚ïë   SPREAD: ${:.2} ({:.4}%)                 ‚ïë",
                spread, self.spread_percent().unwrap_or(0.0));
        }
        println!("‚ïë‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïë");

        // Bids
        println!("‚ïë              BIDS (Buy)                  ‚ïë");
        println!("‚ïë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïë");
        for (price, qty) in self.top_bids(depth) {
            println!("‚ïë   {:>10.2}  ‚îÇ  {:>10.4}               ‚ïë", price, qty);
        }

        println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        println!("\nüìä Statistics:");
        println!("   Mid Price: ${:.2}", self.mid_price().unwrap_or(0.0));
        println!("   Bid Volume: {:.4}", self.total_bid_volume());
        println!("   Ask Volume: {:.4}", self.total_ask_volume());
        println!("   Imbalance: {:.2}% (bids)", self.order_imbalance() * 100.0);
    }
}

fn main() {
    let mut book = OrderBook::new("BTC/USDT", 2);

    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É (bids)
    book.add_order(42100.0, 1.5, Side::Bid);
    book.add_order(42050.0, 2.0, Side::Bid);
    book.add_order(42000.0, 3.5, Side::Bid);
    book.add_order(41950.0, 1.8, Side::Bid);
    book.add_order(41900.0, 4.2, Side::Bid);

    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É (asks)
    book.add_order(42150.0, 1.2, Side::Ask);
    book.add_order(42200.0, 2.5, Side::Ask);
    book.add_order(42250.0, 1.8, Side::Ask);
    book.add_order(42300.0, 3.0, Side::Ask);
    book.add_order(42400.0, 2.2, Side::Ask);

    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∫–Ω–∏–≥—É –∑–∞—è–≤–æ–∫
    book.display(5);
}
```

## –ß–∞—Å—Ç—å 4: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä—ã–Ω–æ—á–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤

–î–æ–±–∞–≤–∏–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –¥–ª—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Ä—ã–Ω–æ—á–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤:

```rust
/// –†–µ–∑—É–ª—å—Ç–∞—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞
#[derive(Debug)]
pub struct ExecutionResult {
    pub filled_quantity: f64,
    pub average_price: f64,
    pub fills: Vec<Fill>,
}

#[derive(Debug)]
pub struct Fill {
    pub price: f64,
    pub quantity: f64,
    pub order_id: u64,
}

impl OrderBook {
    /// –ò—Å–ø–æ–ª–Ω–∏—Ç—å —Ä—ã–Ω–æ—á–Ω—ã–π –æ—Ä–¥–µ—Ä –Ω–∞ –ø–æ–∫—É–ø–∫—É
    pub fn execute_market_buy(&mut self, quantity: f64) -> ExecutionResult {
        let mut remaining = quantity;
        let mut fills = Vec::new();
        let mut total_cost = 0.0;
        let mut keys_to_remove = Vec::new();

        for (&key, level) in self.asks.iter_mut() {
            if remaining <= 0.0 {
                break;
            }

            while let Some(mut order) = level.orders.pop_front() {
                if remaining <= 0.0 {
                    level.orders.push_front(order);
                    break;
                }

                let fill_qty = remaining.min(order.quantity);
                fills.push(Fill {
                    price: order.price,
                    quantity: fill_qty,
                    order_id: order.id,
                });

                total_cost += fill_qty * order.price;
                remaining -= fill_qty;
                order.quantity -= fill_qty;

                if order.quantity > 0.0 {
                    level.orders.push_front(order);
                    break;
                }
            }

            if level.is_empty() {
                keys_to_remove.push(key);
            }
        }

        // –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —É—Ä–æ–≤–Ω–∏
        for key in keys_to_remove {
            self.asks.remove(&key);
        }

        let filled_quantity = quantity - remaining;
        let average_price = if filled_quantity > 0.0 {
            total_cost / filled_quantity
        } else {
            0.0
        };

        ExecutionResult {
            filled_quantity,
            average_price,
            fills,
        }
    }

    /// –ò—Å–ø–æ–ª–Ω–∏—Ç—å —Ä—ã–Ω–æ—á–Ω—ã–π –æ—Ä–¥–µ—Ä –Ω–∞ –ø—Ä–æ–¥–∞–∂—É
    pub fn execute_market_sell(&mut self, quantity: f64) -> ExecutionResult {
        let mut remaining = quantity;
        let mut fills = Vec::new();
        let mut total_revenue = 0.0;
        let mut keys_to_remove = Vec::new();

        for (&key, level) in self.bids.iter_mut() {
            if remaining <= 0.0 {
                break;
            }

            while let Some(mut order) = level.orders.pop_front() {
                if remaining <= 0.0 {
                    level.orders.push_front(order);
                    break;
                }

                let fill_qty = remaining.min(order.quantity);
                fills.push(Fill {
                    price: order.price,
                    quantity: fill_qty,
                    order_id: order.id,
                });

                total_revenue += fill_qty * order.price;
                remaining -= fill_qty;
                order.quantity -= fill_qty;

                if order.quantity > 0.0 {
                    level.orders.push_front(order);
                    break;
                }
            }

            if level.is_empty() {
                keys_to_remove.push(key);
            }
        }

        for key in keys_to_remove {
            self.bids.remove(&key);
        }

        let filled_quantity = quantity - remaining;
        let average_price = if filled_quantity > 0.0 {
            total_revenue / filled_quantity
        } else {
            0.0
        };

        ExecutionResult {
            filled_quantity,
            average_price,
            fills,
        }
    }
}
```

## –ß–∞—Å—Ç—å 5: –ê–Ω–∞–ª–∏–∑ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏

```rust
impl OrderBook {
    /// –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Ü–µ–Ω—É –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –æ–±—ä—ë–º–∞
    pub fn price_for_buy(&self, quantity: f64) -> Option<f64> {
        let mut remaining = quantity;
        let mut total_cost = 0.0;

        for level in self.asks.values() {
            if remaining <= 0.0 {
                break;
            }

            let available = level.total_quantity();
            let fill_qty = remaining.min(available);
            total_cost += fill_qty * level.price;
            remaining -= fill_qty;
        }

        if remaining > 0.0 {
            None // –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
        } else {
            Some(total_cost / quantity)
        }
    }

    /// –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Ü–µ–Ω—É –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –æ–±—ä—ë–º–∞
    pub fn price_for_sell(&self, quantity: f64) -> Option<f64> {
        let mut remaining = quantity;
        let mut total_revenue = 0.0;

        for level in self.bids.values() {
            if remaining <= 0.0 {
                break;
            }

            let available = level.total_quantity();
            let fill_qty = remaining.min(available);
            total_revenue += fill_qty * level.price;
            remaining -= fill_qty;
        }

        if remaining > 0.0 {
            None
        } else {
            Some(total_revenue / quantity)
        }
    }

    /// –†–∞—Å—Å—á–∏—Ç–∞—Ç—å slippage (–ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ) –¥–ª—è –ø–æ–∫—É–ø–∫–∏
    pub fn buy_slippage(&self, quantity: f64) -> Option<f64> {
        let exec_price = self.price_for_buy(quantity)?;
        let best_ask = self.best_ask()?.0;
        Some((exec_price - best_ask) / best_ask * 100.0)
    }

    /// –†–∞—Å—Å—á–∏—Ç–∞—Ç—å slippage –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏
    pub fn sell_slippage(&self, quantity: f64) -> Option<f64> {
        let exec_price = self.price_for_sell(quantity)?;
        let best_bid = self.best_bid()?.0;
        Some((best_bid - exec_price) / best_bid * 100.0)
    }

    /// –ì–ª—É–±–∏–Ω–∞ —Ä—ã–Ω–∫–∞ –¥–æ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π —Ü–µ–Ω—ã
    pub fn depth_to_price(&self, side: Side, target_price: f64) -> f64 {
        match side {
            Side::Bid => {
                self.bids
                    .values()
                    .filter(|l| l.price >= target_price)
                    .map(|l| l.total_quantity())
                    .sum()
            }
            Side::Ask => {
                self.asks
                    .values()
                    .filter(|l| l.price <= target_price)
                    .map(|l| l.total_quantity())
                    .sum()
            }
        }
    }
}

fn main() {
    let mut book = OrderBook::new("BTC/USDT", 2);

    // –ù–∞–ø–æ–ª–Ω—è–µ–º –∫–Ω–∏–≥—É
    for i in 0..10 {
        book.add_order(42000.0 - (i as f64 * 50.0), 1.0 + (i as f64 * 0.5), Side::Bid);
        book.add_order(42100.0 + (i as f64 * 50.0), 1.0 + (i as f64 * 0.5), Side::Ask);
    }

    book.display(5);

    // –ê–Ω–∞–ª–∏–∑ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
    println!("\nüìà Liquidity Analysis:");

    for qty in [1.0, 5.0, 10.0, 20.0] {
        if let Some(price) = book.price_for_buy(qty) {
            let slippage = book.buy_slippage(qty).unwrap_or(0.0);
            println!("   Buy {} BTC @ ${:.2} (slippage: {:.4}%)", qty, price, slippage);
        } else {
            println!("   Buy {} BTC: Insufficient liquidity!", qty);
        }
    }
}
```

## –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 1: –û—Ç–º–µ–Ω–∞ –æ—Ä–¥–µ—Ä–æ–≤

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –º–µ—Ç–æ–¥ `cancel_order` –∫–æ—Ç–æ—Ä—ã–π —É–¥–∞–ª—è–µ—Ç –æ—Ä–¥–µ—Ä –ø–æ –µ–≥–æ ID:

```rust
impl OrderBook {
    pub fn cancel_order(&mut self, order_id: u64) -> Option<Order> {
        // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
        // –ü–æ–¥—Å–∫–∞–∑–∫–∞: –Ω—É–∂–Ω–æ –∏—Å–∫–∞—Ç—å –≤ –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω–∞—Ö (bids –∏ asks)
        todo!()
    }
}
```

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 2: –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –æ—Ä–¥–µ—Ä–∞

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –º–µ—Ç–æ–¥ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤ –æ—Ä–¥–µ—Ä–µ:

```rust
impl OrderBook {
    pub fn modify_order(&mut self, order_id: u64, new_quantity: f64) -> bool {
        // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
        // –ü–æ–¥—Å–∫–∞–∑–∫–∞: –Ω–∞–π—Ç–∏ –æ—Ä–¥–µ—Ä –∏ –∏–∑–º–µ–Ω–∏—Ç—å –µ–≥–æ quantity
        todo!()
    }
}
```

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 3: –ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—Ç–∞–∫–∞–Ω

–°–æ–∑–¥–∞–π—Ç–µ –º–µ—Ç–æ–¥ –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞–∫–∞–Ω–∞:

```rust
#[derive(Debug)]
pub struct AggregatedLevel {
    pub price: f64,
    pub quantity: f64,
    pub order_count: usize,
    pub cumulative_quantity: f64,  // –ù–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–π –æ–±—ä—ë–º
}

impl OrderBook {
    pub fn aggregated_book(&self, depth: usize) -> (Vec<AggregatedLevel>, Vec<AggregatedLevel>) {
        // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (bids, asks) —Å –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–º –æ–±—ä—ë–º–æ–º
        todo!()
    }
}
```

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 4: VWAP –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä

–†–∞—Å—Å—á–∏—Ç–∞–π—Ç–µ VWAP (Volume Weighted Average Price) –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –æ–±—ä—ë–º–∞:

```rust
impl OrderBook {
    pub fn vwap_buy(&self, quantity: f64) -> Option<f64> {
        // –í–∑–≤–µ—à–µ–Ω–Ω–∞—è –ø–æ –æ–±—ä—ë–º—É —Å—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ quantity
        todo!()
    }

    pub fn vwap_sell(&self, quantity: f64) -> Option<f64> {
        // –í–∑–≤–µ—à–µ–Ω–Ω–∞—è –ø–æ –æ–±—ä—ë–º—É —Å—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏ quantity
        todo!()
    }
}
```

## –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ

### 1. –î–æ–±–∞–≤—å—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∫—É –ª–∏–º–∏—Ç–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤ —Å matching

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ª–æ–≥–∏–∫—É, –∫–æ–≥–¥–∞ –Ω–æ–≤—ã–π –æ—Ä–¥–µ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –º–∞—Ç—á–∏—Ç—Å—è —Å –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π, –µ—Å–ª–∏ —Ü–µ–Ω—ã –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è:

```rust
pub fn add_limit_order(&mut self, price: f64, quantity: f64, side: Side)
    -> (u64, Vec<Fill>) {
    // –ï—Å–ª–∏ buy order —Å —Ü–µ–Ω–æ–π >= best ask ‚Äî —á–∞—Å—Ç–∏—á–Ω–æ –∏–ª–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–ø–æ–ª–Ω–∏—Ç—å
    // –ï—Å–ª–∏ sell order —Å —Ü–µ–Ω–æ–π <= best bid ‚Äî —á–∞—Å—Ç–∏—á–Ω–æ –∏–ª–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–ø–æ–ª–Ω–∏—Ç—å
    // –û—Å—Ç–∞—Ç–æ–∫ –¥–æ–±–∞–≤–∏—Ç—å –≤ –∫–Ω–∏–≥—É
}
```

### 2. Order Book —Å–Ω—ç–ø—à–æ—Ç—ã –∏ –¥–µ–ª—å—Ç–∞-–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º—É –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–Ω—ç–ø—à–æ—Ç–æ–≤ –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –¥–µ–ª—å—Ç–∞-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–π:

```rust
#[derive(Debug, Clone)]
pub struct OrderBookSnapshot {
    pub symbol: String,
    pub bids: Vec<(f64, f64)>,
    pub asks: Vec<(f64, f64)>,
    pub timestamp: u64,
}

#[derive(Debug)]
pub enum DeltaUpdate {
    Add { side: Side, price: f64, quantity: f64 },
    Remove { side: Side, price: f64 },
    Update { side: Side, price: f64, quantity: f64 },
}

impl OrderBook {
    pub fn snapshot(&self, depth: usize) -> OrderBookSnapshot { todo!() }
    pub fn apply_delta(&mut self, delta: DeltaUpdate) { todo!() }
}
```

### 3. –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≥–ª—É–±–∏–Ω—ã —Ä—ã–Ω–∫–∞

–°–æ–∑–¥–∞–π—Ç–µ ASCII-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –≥–ª—É–±–∏–Ω—ã —Ä—ã–Ω–∫–∞:

```
DEPTH CHART: BTC/USDT
    ASK ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  42400: 15.5 BTC
        ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  42300: 10.2 BTC
        ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  42200:  6.5 BTC
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  SPREAD: $100
    BID ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  42100:  8.0 BTC
        ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  42000: 12.3 BTC
        ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  41900: 18.7 BTC
```

### 4. –ê–Ω–∞–ª–∏–∑ –º–∏–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä—ã

–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–∞—Å—á—ë—Ç –ø–æ–∫–∞–∑–∞—Ç–µ–ª–µ–π –º–∏–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ä—ã–Ω–∫–∞:

```rust
pub struct MicrostructureMetrics {
    pub bid_ask_spread: f64,
    pub spread_bps: f64,        // Spread –≤ –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–∞—Ö
    pub order_imbalance: f64,
    pub depth_imbalance: f64,   // –î–∏—Å–±–∞–ª–∞–Ω—Å –Ω–∞ –ø–µ—Ä–≤—ã—Ö N —É—Ä–æ–≤–Ω—è—Ö
    pub weighted_mid_price: f64, // –í–∑–≤–µ—à–µ–Ω–Ω—ã–π mid price
}

impl OrderBook {
    pub fn microstructure_metrics(&self, depth: usize) -> MicrostructureMetrics {
        todo!()
    }
}
```

## –ß—Ç–æ –º—ã –∏–∑—É—á–∏–ª–∏

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ |
|-----------|------------|
| `struct` | –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ Order, PriceLevel, OrderBook |
| `enum` | Side (Bid/Ask), —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–ø–µ—Ä–∞—Ü–∏–π |
| `BTreeMap` | –û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π —Ü–µ–Ω |
| `VecDeque` | FIFO-–æ—á–µ—Ä–µ–¥—å –æ—Ä–¥–µ—Ä–æ–≤ |
| `impl` | –ú–µ—Ç–æ–¥—ã –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä |
| –ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã | –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–π |
| `Option` | –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö |

## –ö–ª—é—á–µ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞

- **Order Book** ‚Äî —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –±–∏—Ä–∂–∏
- **Spread** ‚Äî –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ —Ä—ã–Ω–∫–∞
- **Slippage** ‚Äî —Ä–µ–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –∫—Ä—É–ø–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤
- **Order Imbalance** ‚Äî –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä –∫—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è —Ü–µ–Ω—ã
- **Depth** ‚Äî —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å —Ü–µ–Ω—ã –∫ –∫—Ä—É–ø–Ω—ã–º –æ—Ä–¥–µ—Ä–∞–º

## –ù–∞–≤–∏–≥–∞—Ü–∏—è

[‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å](../089-btreemap-sorted-prices/ru.md) | [–°–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å ‚Üí](../091-vectors-dynamic-orders/ru.md)
