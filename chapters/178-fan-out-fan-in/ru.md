# –î–µ–Ω—å 178: –ü–∞—Ç—Ç–µ—Ä–Ω Fan-out Fan-in

## –ê–Ω–∞–ª–æ–≥–∏—è –∏–∑ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞

–ü—Ä–µ–¥—Å—Ç–∞–≤—å, —á—Ç–æ —Ç—ã —É–ø—Ä–∞–≤–ª—è–µ—à—å —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π, –∫–æ—Ç–æ—Ä–∞—è –¥–æ–ª–∂–Ω–∞ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —Å 10 –±–∏—Ä–∂ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –¢—ã –º–æ–≥ –±—ã –¥–µ–ª–∞—Ç—å —ç—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ ‚Äî —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å Binance, –ø–æ—Ç–æ–º Kraken, –∑–∞—Ç–µ–º Coinbase... –ù–æ —ç—Ç–æ –∑–∞–π–º—ë—Ç –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏!

–í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ —Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ—à—å –ø–∞—Ç—Ç–µ—Ä–Ω **Fan-out Fan-in**:
- **Fan-out (—Ä–∞–∑–≤–µ—Ç–≤–ª–µ–Ω–∏–µ)**: —Ä–∞–∑–¥–∞—ë—à—å –∑–∞–¥–∞—á–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –≤–æ—Ä–∫–µ—Ä–∞–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ ‚Äî –∫–∞–∂–¥—ã–π –≤–æ—Ä–∫–µ—Ä –æ–ø—Ä–∞—à–∏–≤–∞–µ—Ç —Å–≤–æ—é –±–∏—Ä–∂—É
- **Fan-in (—Å—Ö–æ–∂–¥–µ–Ω–∏–µ)**: —Å–æ–±–∏—Ä–∞–µ—à—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç –≤—Å–µ—Ö –≤–æ—Ä–∫–µ—Ä–æ–≤ –≤ –æ–¥–∏–Ω –ø–æ—Ç–æ–∫ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

–≠—Ç–æ –∫–∞–∫ –µ—Å–ª–∏ –±—ã —Ç—ã –æ—Ç–ø—Ä–∞–≤–∏–ª 10 –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–≤ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Ü–µ–Ω—ã –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –±–∏—Ä–∂–∞—Ö, –∞ –ø–æ—Ç–æ–º –æ–Ω–∏ –≤—Å–µ —Å–æ–æ–±—â–∞—é—Ç —Ç–µ–±–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, –∏ —Ç—ã –≤—ã–±–∏—Ä–∞–µ—à—å –ª—É—á—à—É—é —Ü–µ–Ω—É.

```
                    ‚îå‚îÄ‚îÄ> –í–æ—Ä–∫–µ—Ä 1 (Binance)  ‚îÄ‚îÄ‚îê
                    ‚îÇ                          ‚îÇ
–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ> –í–æ—Ä–∫–µ—Ä 2 (Kraken)   ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ> –ê–≥—Ä–µ–≥–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
     (Fan-out)      ‚îÇ                          ‚îÇ         (Fan-in)
                    ‚îî‚îÄ‚îÄ> –í–æ—Ä–∫–µ—Ä 3 (Coinbase) ‚îÄ‚îÄ‚îò
```

## –ß—Ç–æ —Ç–∞–∫–æ–µ Fan-out Fan-in?

**Fan-out Fan-in** ‚Äî —ç—Ç–æ –ø–∞—Ç—Ç–µ—Ä–Ω –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏, –≥–¥–µ:

1. **Fan-out**: –æ–¥–Ω–∞ –∑–∞–¥–∞—á–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –º–µ–∂–¥—É –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º–∏
2. **Fan-in**: —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç –≤—Å–µ—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è –≤ –æ–¥–Ω–æ –º–µ—Å—Ç–æ

–≠—Ç–æ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω –∏–¥–µ–∞–ª–µ–Ω –¥–ª—è:
- –ê–≥—Ä–µ–≥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
- –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- –†–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π

## –ü—Ä–æ—Å—Ç–æ–π –ø—Ä–∏–º–µ—Ä: –∞–Ω–∞–ª–∏–∑ —Ü–µ–Ω —Å –±–∏—Ä–∂

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

#[derive(Debug, Clone)]
struct PriceData {
    exchange: String,
    symbol: String,
    price: f64,
    volume: f64,
}

fn main() {
    // –ö–∞–Ω–∞–ª –¥–ª—è —Å–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (Fan-in)
    let (tx, rx) = mpsc::channel();

    let exchanges = vec![
        ("Binance", 42150.0, 1000.0),
        ("Kraken", 42145.0, 800.0),
        ("Coinbase", 42160.0, 1200.0),
        ("Bitstamp", 42140.0, 500.0),
        ("Gemini", 42155.0, 600.0),
    ];

    // Fan-out: –∑–∞–ø—É—Å–∫–∞–µ–º –≤–æ—Ä–∫–µ—Ä –¥–ª—è –∫–∞–∂–¥–æ–π –±–∏—Ä–∂–∏
    for (exchange, price, volume) in exchanges {
        let tx = tx.clone();
        thread::spawn(move || {
            // –ò–º–∏—Ç–∞—Ü–∏—è —Å–µ—Ç–µ–≤–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏
            thread::sleep(Duration::from_millis(100 + (price as u64 % 50)));

            let data = PriceData {
                exchange: exchange.to_string(),
                symbol: "BTC/USD".to_string(),
                price,
                volume,
            };

            println!("[{}] –ü–æ–ª—É—á–µ–Ω–∞ —Ü–µ–Ω–∞: ${:.2}", exchange, price);
            tx.send(data).unwrap();
        });
    }

    // –í–∞–∂–Ω–æ: —É–¥–∞–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å
    drop(tx);

    // Fan-in: —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    let mut prices: Vec<PriceData> = Vec::new();
    for data in rx {
        prices.push(data);
    }

    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ–±—Ä–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    println!("\n=== –ê–Ω–∞–ª–∏–∑ —Ä—ã–Ω–∫–∞ ===");

    let best_bid = prices.iter()
        .max_by(|a, b| a.price.partial_cmp(&b.price).unwrap())
        .unwrap();

    let best_ask = prices.iter()
        .min_by(|a, b| a.price.partial_cmp(&b.price).unwrap())
        .unwrap();

    let avg_price: f64 = prices.iter().map(|p| p.price).sum::<f64>() / prices.len() as f64;
    let total_volume: f64 = prices.iter().map(|p| p.volume).sum();

    println!("–õ—É—á—à–∞—è —Ü–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏: {} @ ${:.2}", best_bid.exchange, best_bid.price);
    println!("–õ—É—á—à–∞—è —Ü–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏: {} @ ${:.2}", best_ask.exchange, best_ask.price);
    println!("–°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞: ${:.2}", avg_price);
    println!("–û–±—â–∏–π –æ–±—ä—ë–º: {:.0} BTC", total_volume);
    println!("–°–ø—Ä–µ–¥: ${:.2}", best_bid.price - best_ask.price);
}
```

## Fan-out —Å –ø—É–ª–æ–º –≤–æ—Ä–∫–µ—Ä–æ–≤

–í —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö –º—ã –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –≤–æ—Ä–∫–µ—Ä–æ–≤:

```rust
use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

#[derive(Debug, Clone)]
struct TradeSignal {
    symbol: String,
    signal_type: String,
    strength: f64,
}

#[derive(Debug)]
struct AnalysisResult {
    symbol: String,
    recommendation: String,
    confidence: f64,
}

fn main() {
    // –û—á–µ—Ä–µ–¥—å –∑–∞–¥–∞—á (—Å–∏–º–≤–æ–ª—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞)
    let symbols = vec![
        "BTC/USD", "ETH/USD", "SOL/USD", "ADA/USD",
        "DOT/USD", "LINK/USD", "AVAX/USD", "MATIC/USD",
    ];

    let tasks: Arc<Mutex<VecDeque<String>>> = Arc::new(Mutex::new(
        symbols.iter().map(|s| s.to_string()).collect()
    ));

    let (tx, rx) = mpsc::channel();

    // –°–æ–∑–¥–∞—ë–º –ø—É–ª –∏–∑ 3 –≤–æ—Ä–∫–µ—Ä–æ–≤ (Fan-out —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º)
    let num_workers = 3;
    let mut handles = vec![];

    for worker_id in 0..num_workers {
        let tasks = Arc::clone(&tasks);
        let tx = tx.clone();

        let handle = thread::spawn(move || {
            loop {
                // –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á—É –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                let symbol = {
                    let mut queue = tasks.lock().unwrap();
                    queue.pop_front()
                };

                match symbol {
                    Some(symbol) => {
                        println!("–í–æ—Ä–∫–µ—Ä {} –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç {}", worker_id, symbol);

                        // –ò–º–∏—Ç–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞
                        thread::sleep(std::time::Duration::from_millis(150));

                        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞
                        let strength = (worker_id as f64 * 0.1) + 0.7;
                        let result = AnalysisResult {
                            symbol: symbol.clone(),
                            recommendation: if strength > 0.75 {
                                "BUY".to_string()
                            } else {
                                "HOLD".to_string()
                            },
                            confidence: strength,
                        };

                        tx.send(result).unwrap();
                    }
                    None => break, // –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞
                }
            }
            println!("–í–æ—Ä–∫–µ—Ä {} –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞–±–æ—Ç—É", worker_id);
        });

        handles.push(handle);
    }

    drop(tx); // –ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ –≤—Å–µ—Ö –≤–æ—Ä–∫–µ—Ä–æ–≤

    // Fan-in: —Å–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    let mut results: Vec<AnalysisResult> = Vec::new();
    for result in rx {
        println!("  -> {} –ø–æ–ª—É—á–µ–Ω: {} ({:.0}%)",
            result.symbol,
            result.recommendation,
            result.confidence * 100.0
        );
        results.push(result);
    }

    // –ñ–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –≤–æ—Ä–∫–µ—Ä–æ–≤
    for handle in handles {
        handle.join().unwrap();
    }

    // –ò—Ç–æ–≥–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑
    println!("\n=== –ò—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ ===");
    let buy_signals: Vec<_> = results.iter()
        .filter(|r| r.recommendation == "BUY")
        .collect();

    println!("–°–∏–≥–Ω–∞–ª—ã –Ω–∞ –ø–æ–∫—É–ø–∫—É: {} –∏–∑ {}", buy_signals.len(), results.len());
    for signal in buy_signals {
        println!("  {} (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {:.0}%)", signal.symbol, signal.confidence * 100.0);
    }
}
```

## –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ø–æ—Ä—Ç—Ñ–µ–ª—è

–ò—Å–ø–æ–ª—å–∑—É–µ–º Fan-out Fan-in –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –º–µ—Ç—Ä–∏–∫ –ø–æ—Ä—Ç—Ñ–µ–ª—è:

```rust
use std::sync::mpsc;
use std::thread;
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct Position {
    symbol: String,
    quantity: f64,
    entry_price: f64,
    current_price: f64,
}

#[derive(Debug)]
struct PositionMetrics {
    symbol: String,
    pnl: f64,
    pnl_percent: f64,
    value: f64,
    risk_score: f64,
}

fn calculate_position_metrics(position: Position) -> PositionMetrics {
    // –ò–º–∏—Ç–∞—Ü–∏—è —Å–ª–æ–∂–Ω–æ–≥–æ —Ä–∞—Å—á—ë—Ç–∞
    thread::sleep(std::time::Duration::from_millis(50));

    let pnl = (position.current_price - position.entry_price) * position.quantity;
    let pnl_percent = ((position.current_price / position.entry_price) - 1.0) * 100.0;
    let value = position.current_price * position.quantity;

    // –ü—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á—ë—Ç —Ä–∏—Å–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
    let risk_score = (pnl_percent.abs() / 10.0).min(1.0);

    PositionMetrics {
        symbol: position.symbol,
        pnl,
        pnl_percent,
        value,
        risk_score,
    }
}

fn main() {
    let portfolio = vec![
        Position { symbol: "BTC".to_string(), quantity: 2.5, entry_price: 40000.0, current_price: 42000.0 },
        Position { symbol: "ETH".to_string(), quantity: 30.0, entry_price: 2500.0, current_price: 2650.0 },
        Position { symbol: "SOL".to_string(), quantity: 100.0, entry_price: 100.0, current_price: 95.0 },
        Position { symbol: "ADA".to_string(), quantity: 5000.0, entry_price: 0.50, current_price: 0.55 },
        Position { symbol: "DOT".to_string(), quantity: 200.0, entry_price: 7.0, current_price: 7.5 },
        Position { symbol: "LINK".to_string(), quantity: 150.0, entry_price: 15.0, current_price: 14.0 },
    ];

    let (tx, rx) = mpsc::channel();

    println!("–ó–∞–ø—É—Å–∫ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ {} –ø–æ–∑–∏—Ü–∏–π...\n", portfolio.len());
    let start = std::time::Instant::now();

    // Fan-out: –∫–∞–∂–¥–∞—è –ø–æ–∑–∏—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    for position in portfolio {
        let tx = tx.clone();
        thread::spawn(move || {
            let metrics = calculate_position_metrics(position);
            tx.send(metrics).unwrap();
        });
    }

    drop(tx);

    // Fan-in: —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –º–µ—Ç—Ä–∏–∫–∏
    let mut all_metrics: Vec<PositionMetrics> = Vec::new();
    for metrics in rx {
        all_metrics.push(metrics);
    }

    let elapsed = start.elapsed();

    // –ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –ø–æ—Ä—Ç—Ñ–µ–ª—è
    println!("=== –ê–Ω–∞–ª–∏–∑ –ø–æ—Ä—Ç—Ñ–µ–ª—è (–∑–∞ {:?}) ===\n", elapsed);

    let total_value: f64 = all_metrics.iter().map(|m| m.value).sum();
    let total_pnl: f64 = all_metrics.iter().map(|m| m.pnl).sum();
    let avg_risk: f64 = all_metrics.iter().map(|m| m.risk_score).sum::<f64>()
        / all_metrics.len() as f64;

    println!("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
    println!("‚ïë                 –ú–ï–¢–†–ò–ö–ò –ü–û–†–¢–§–ï–õ–Ø                     ‚ïë");
    println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");

    for m in &all_metrics {
        let pnl_indicator = if m.pnl >= 0.0 { "+" } else { "" };
        println!("‚ïë {:6} | PnL: {}${:>10.2} ({:>+6.2}%) | Risk: {:.2} ‚ïë",
            m.symbol,
            pnl_indicator,
            m.pnl.abs(),
            m.pnl_percent,
            m.risk_score
        );
    }

    println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
    println!("‚ïë –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å:    ${:>12.2}                  ‚ïë", total_value);
    println!("‚ïë –û–±—â–∏–π PnL:          ${:>12.2}                  ‚ïë", total_pnl);
    println!("‚ïë –°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫:       {:>13.2}                  ‚ïë", avg_risk);
    println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏, —Ç—Ä–µ–±—É—é—â–∏–µ –≤–Ω–∏–º–∞–Ω–∏—è
    let risky_positions: Vec<_> = all_metrics.iter()
        .filter(|m| m.risk_score > 0.5)
        .collect();

    if !risky_positions.is_empty() {
        println!("\n‚ö†Ô∏è  –ü–æ–∑–∏—Ü–∏–∏ —Å –ø–æ–≤—ã—à–µ–Ω–Ω—ã–º —Ä–∏—Å–∫–æ–º:");
        for pos in risky_positions {
            println!("   - {} (—Ä–∏—Å–∫: {:.2})", pos.symbol, pos.risk_score);
        }
    }
}
```

## –°–∫–∞–Ω–µ—Ä —Ä—ã–Ω–∫–∞ —Å Fan-out Fan-in

–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –ø—Ä–∏–º–µ—Ä —Å–∫–∞–Ω–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –∏—â–µ—Ç —Ç–æ—Ä–≥–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

#[derive(Debug, Clone)]
struct MarketData {
    symbol: String,
    price: f64,
    volume_24h: f64,
    change_24h: f64,
    rsi: f64,
}

#[derive(Debug)]
struct TradingOpportunity {
    symbol: String,
    signal: String,
    entry_price: f64,
    target_price: f64,
    stop_loss: f64,
    score: f64,
}

fn scan_symbol(data: MarketData) -> Option<TradingOpportunity> {
    // –ò–º–∏—Ç–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞
    thread::sleep(Duration::from_millis(100));

    // –£—Å–ª–æ–≤–∏—è –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
    let is_oversold = data.rsi < 30.0;
    let is_overbought = data.rsi > 70.0;
    let high_volume = data.volume_24h > 1_000_000.0;
    let significant_drop = data.change_24h < -5.0;
    let significant_rise = data.change_24h > 5.0;

    if is_oversold && high_volume && significant_drop {
        // –°–∏–≥–Ω–∞–ª –Ω–∞ –ø–æ–∫—É–ø–∫—É
        Some(TradingOpportunity {
            symbol: data.symbol,
            signal: "BUY".to_string(),
            entry_price: data.price,
            target_price: data.price * 1.10, // +10%
            stop_loss: data.price * 0.95,    // -5%
            score: (30.0 - data.rsi) / 30.0 + (data.change_24h.abs() / 10.0),
        })
    } else if is_overbought && high_volume && significant_rise {
        // –°–∏–≥–Ω–∞–ª –Ω–∞ –ø—Ä–æ–¥–∞–∂—É
        Some(TradingOpportunity {
            symbol: data.symbol,
            signal: "SELL".to_string(),
            entry_price: data.price,
            target_price: data.price * 0.90, // -10%
            stop_loss: data.price * 1.05,    // +5%
            score: (data.rsi - 70.0) / 30.0 + (data.change_24h / 10.0),
        })
    } else {
        None
    }
}

fn main() {
    // –°–∏–º—É–ª—è—Ü–∏—è —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    let market_data = vec![
        MarketData { symbol: "BTC".to_string(), price: 42000.0, volume_24h: 5_000_000.0, change_24h: -7.5, rsi: 25.0 },
        MarketData { symbol: "ETH".to_string(), price: 2600.0, volume_24h: 2_000_000.0, change_24h: 2.0, rsi: 55.0 },
        MarketData { symbol: "SOL".to_string(), price: 95.0, volume_24h: 1_500_000.0, change_24h: 8.0, rsi: 78.0 },
        MarketData { symbol: "ADA".to_string(), price: 0.55, volume_24h: 800_000.0, change_24h: -3.0, rsi: 42.0 },
        MarketData { symbol: "DOT".to_string(), price: 7.5, volume_24h: 1_200_000.0, change_24h: -6.0, rsi: 28.0 },
        MarketData { symbol: "AVAX".to_string(), price: 35.0, volume_24h: 900_000.0, change_24h: 1.5, rsi: 50.0 },
        MarketData { symbol: "LINK".to_string(), price: 14.0, volume_24h: 1_100_000.0, change_24h: 6.5, rsi: 72.0 },
        MarketData { symbol: "MATIC".to_string(), price: 0.85, volume_24h: 600_000.0, change_24h: -2.0, rsi: 38.0 },
    ];

    let (tx, rx) = mpsc::channel();

    println!("üîç –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä—ã–Ω–∫–∞ ({} —Å–∏–º–≤–æ–ª–æ–≤)...\n", market_data.len());
    let start = std::time::Instant::now();

    // Fan-out: –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
    for data in market_data {
        let tx = tx.clone();
        thread::spawn(move || {
            let result = scan_symbol(data);
            tx.send(result).unwrap();
        });
    }

    drop(tx);

    // Fan-in: —Å–±–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    let mut opportunities: Vec<TradingOpportunity> = Vec::new();
    for result in rx {
        if let Some(opp) = result {
            opportunities.push(opp);
        }
    }

    let elapsed = start.elapsed();

    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–∏–ª–µ —Å–∏–≥–Ω–∞–ª–∞
    opportunities.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());

    println!("=== –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (–∑–∞ {:?}) ===\n", elapsed);

    if opportunities.is_empty() {
        println!("–¢–æ—Ä–≥–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.");
    } else {
        println!("–ù–∞–π–¥–µ–Ω–æ {} —Ç–æ—Ä–≥–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π:\n", opportunities.len());

        for (i, opp) in opportunities.iter().enumerate() {
            let emoji = if opp.signal == "BUY" { "üü¢" } else { "üî¥" };
            println!("{}. {} {} {}", i + 1, emoji, opp.signal, opp.symbol);
            println!("   –í—Ö–æ–¥: ${:.4}", opp.entry_price);
            println!("   –¶–µ–ª—å: ${:.4}", opp.target_price);
            println!("   –°—Ç–æ–ø: ${:.4}", opp.stop_loss);
            println!("   –°–∏–ª–∞ —Å–∏–≥–Ω–∞–ª–∞: {:.2}\n", opp.score);
        }
    }
}
```

## Fan-out Fan-in —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫

–í —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö –≤–∞–∂–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

#[derive(Debug)]
enum FetchError {
    Timeout,
    NetworkError(String),
    ParseError,
}

#[derive(Debug)]
struct ExchangePrice {
    exchange: String,
    price: f64,
}

type FetchResult = Result<ExchangePrice, (String, FetchError)>;

fn fetch_price(exchange: &str, should_fail: bool) -> FetchResult {
    // –ò–º–∏—Ç–∞—Ü–∏—è —Å–µ—Ç–µ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    thread::sleep(Duration::from_millis(100));

    if should_fail {
        return Err((exchange.to_string(), FetchError::NetworkError("Connection refused".to_string())));
    }

    // –ò–º–∏—Ç–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
    let base_price = 42000.0;
    let variation = (exchange.len() as f64 * 10.0) - 30.0;

    Ok(ExchangePrice {
        exchange: exchange.to_string(),
        price: base_price + variation,
    })
}

fn main() {
    let exchanges = vec![
        ("Binance", false),
        ("Kraken", true),      // –ò–º–∏—Ç–∞—Ü–∏—è –æ—à–∏–±–∫–∏
        ("Coinbase", false),
        ("Bitstamp", false),
        ("Gemini", true),      // –ò–º–∏—Ç–∞—Ü–∏—è –æ—à–∏–±–∫–∏
    ];

    let (tx, rx) = mpsc::channel();

    println!("–ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω —Å {} –±–∏—Ä–∂...\n", exchanges.len());

    // Fan-out —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
    for (exchange, should_fail) in exchanges {
        let tx = tx.clone();
        thread::spawn(move || {
            let result = fetch_price(exchange, should_fail);
            tx.send(result).unwrap();
        });
    }

    drop(tx);

    // Fan-in —Å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º —É—Å–ø–µ—à–Ω—ã—Ö –∏ –Ω–µ—É—Å–ø–µ—à–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    let mut successful: Vec<ExchangePrice> = Vec::new();
    let mut failed: Vec<(String, FetchError)> = Vec::new();

    for result in rx {
        match result {
            Ok(price) => {
                println!("‚úÖ {}: ${:.2}", price.exchange, price.price);
                successful.push(price);
            }
            Err((exchange, error)) => {
                println!("‚ùå {}: {:?}", exchange, error);
                failed.push((exchange, error));
            }
        }
    }

    println!("\n=== –ò—Ç–æ–≥ ===");
    println!("–£—Å–ø–µ—à–Ω–æ: {}", successful.len());
    println!("–û—à–∏–±–∫–∏: {}", failed.len());

    if !successful.is_empty() {
        let avg_price: f64 = successful.iter().map(|p| p.price).sum::<f64>()
            / successful.len() as f64;
        println!("–°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ (–∏–∑ —É—Å–ø–µ—à–Ω—ã—Ö): ${:.2}", avg_price);
    }

    // –î–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–∏—Å—Ç–µ–º –º–æ–∂–Ω–æ —Ç—Ä–µ–±–æ–≤–∞—Ç—å –º–∏–Ω–∏–º—É–º N —É—Å–ø–µ—à–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤
    let min_required = 3;
    if successful.len() < min_required {
        println!("\n‚ö†Ô∏è  –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –ø–æ–ª—É—á–µ–Ω–æ –º–µ–Ω—å—à–µ {} –æ—Ç–≤–µ—Ç–æ–≤, –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ—Ç–æ—á–Ω—ã–º–∏", min_required);
    }
}
```

## –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞—Ç—Ç–µ—Ä–Ω–∞

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     FAN-OUT FAN-IN                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ   –í—Ö–æ–¥–Ω—ã–µ       Fan-out           Fan-in        –†–µ–∑—É–ª—å—Ç–∞—Ç   ‚îÇ
‚îÇ   –¥–∞–Ω–Ω—ã–µ                                                    ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
‚îÇ              ‚îå‚îÄ‚îÄ‚îÇ –í–æ—Ä–∫–µ—Ä 1‚îÇ‚îÄ‚îÄ‚îê                              ‚îÇ
‚îÇ              ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ                              ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ   ‚îÇ–ó–∞–¥–∞—á–∏‚îÇ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÇ –í–æ—Ä–∫–µ—Ä 2‚îÇ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÇ–ê–≥—Ä–µ–≥–∞—Ç–æ—Ä ‚îÇ‚îÄ‚îÄ‚îÄ‚îÇ–†–µ–∑—É–ª—å—Ç–∞—Ç‚îÇ ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ              ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ                              ‚îÇ
‚îÇ              ‚îî‚îÄ‚îÄ‚îÇ –í–æ—Ä–∫–µ—Ä N‚îÇ‚îÄ‚îÄ‚îò                              ‚îÇ
‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ   ‚Ä¢ –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ   ‚Ä¢ –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è   ‚Ä¢ –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ          ‚îÇ
‚îÇ     –Ω–∞–≥—Ä—É–∑–∫–∏          –æ–±—Ä–∞–±–æ—Ç–∫–∞        —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤          ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## –ß—Ç–æ –º—ã —É–∑–Ω–∞–ª–∏

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –û–ø–∏—Å–∞–Ω–∏–µ |
|-----------|----------|
| Fan-out | –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –º–µ–∂–¥—É –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º–∏ |
| Fan-in | –°–±–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç –≤—Å–µ—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –≤ –æ–¥–Ω–æ –º–µ—Å—Ç–æ |
| –ü—É–ª –≤–æ—Ä–∫–µ—Ä–æ–≤ | –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ—Ä–∫–µ—Ä–æ–≤ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è —Ä–µ—Å—É—Ä—Å–æ–≤ |
| `mpsc::channel` | –û—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è Fan-in –≤ Rust |
| –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ | –í–∞–∂–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —É—Å–ø–µ—à–Ω—ã–µ –∏ –Ω–µ—É—Å–ø–µ—à–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã |
| –ê–≥—Ä–µ–≥–∞—Ü–∏—è | –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∏—Ç–æ–≥–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫ –∏–∑ —Å–æ–±—Ä–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö |

## –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–∞

1. **–ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º**: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –º–Ω–æ–≥–æ –∑–∞–¥–∞—á –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
2. **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ª–µ–≥–∫–æ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ –≤–æ—Ä–∫–µ—Ä–æ–≤
3. **–û—Ç–∫–∞–∑–æ—É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å**: —Å–±–æ–π –æ–¥–Ω–æ–≥–æ –≤–æ—Ä–∫–µ—Ä–∞ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç –≤–µ—Å—å –ø—Ä–æ—Ü–µ—Å—Å
4. **–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å**: –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã CPU

## –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ

1. **–ú—É–ª—å—Ç–∏–±–∏—Ä–∂–µ–≤–æ–π –∞—Ä–±–∏—Ç—Ä–∞–∂**: –†–µ–∞–ª–∏–∑—É–π —Å–∏—Å—Ç–µ–º—É, –∫–æ—Ç–æ—Ä–∞—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –ø–æ–ª—É—á–∞–µ—Ç —Ü–µ–Ω—ã —Å 5 –±–∏—Ä–∂ –∏ –Ω–∞—Ö–æ–¥–∏—Ç –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ (—Ä–∞–∑–Ω–∏—Ü—É –≤ —Ü–µ–Ω–∞—Ö > 0.5%).

2. **–ê–Ω–∞–ª–∏–∑ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π**: –°–æ–∑–¥–∞–π —Å–∏—Å—Ç–µ–º—É, –∫–æ—Ç–æ—Ä–∞—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—é –º–µ–∂–¥—É 10 —Ç–æ—Ä–≥–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–∏ –∏ –≤—ã–≤–æ–¥–∏—Ç –º–∞—Ç—Ä–∏—Ü—É –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π.

3. **–°—Ç—Ä–µ—Å—Å-—Ç–µ—Å—Ç–µ—Ä –ø–æ—Ä—Ç—Ñ–µ–ª—è**: –†–µ–∞–ª–∏–∑—É–π Fan-out Fan-in —Å–∏—Å—Ç–µ–º—É, –∫–æ—Ç–æ—Ä–∞—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –∑–∞–ø—É—Å–∫–∞–µ—Ç 100 —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ Monte-Carlo –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Ä–∏—Å–∫–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è.

4. **–°–∫–∞–Ω–µ—Ä –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤**: –°–æ–∑–¥–∞–π —Å–∫–∞–Ω–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –∏—â–µ—Ç —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã (–≥–æ–ª–æ–≤–∞-–ø–ª–µ—á–∏, –¥–≤–æ–π–Ω–æ–µ –¥–Ω–æ –∏ —Ç.–¥.) –Ω–∞ 20 —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä–∞—Ö –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é.

## –ù–∞–≤–∏–≥–∞—Ü–∏—è

[‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å](../177-pipeline-parallel-processing/ru.md) | [–°–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å ‚Üí](../179-select-waiting-multiple-channels/ru.md)
