# –î–µ–Ω—å 206: –ü–∏–Ω–≥-–ø–æ–Ω–≥: –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è

## –ê–Ω–∞–ª–æ–≥–∏—è –∏–∑ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞

–ü—Ä–µ–¥—Å—Ç–∞–≤—å, —á—Ç–æ —Ç—ã –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –±–∏—Ä–∂–µ —á–µ—Ä–µ–∑ WebSocket –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ—Ç–∏—Ä–æ–≤–æ–∫ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏. –ï—Å–ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–Ω–µ–∑–∞–ø–Ω–æ –ø—Ä–µ—Ä–≤—ë—Ç—Å—è ‚Äî —Ç—ã –º–æ–∂–µ—à—å –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤–∞–∂–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –∏ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–µ–Ω—å–≥–∏. –ù–æ –∫–∞–∫ –±–∏—Ä–∂–∞ –∏ —Ç–≤–æ–π –∫–ª–∏–µ–Ω—Ç —É–∑–Ω–∞—é—Ç, —á—Ç–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –µ—â—ë –∂–∏–≤–æ?

–≠—Ç–æ –∫–∞–∫ –æ—Ö—Ä–∞–Ω–Ω–∏–∫ –Ω–∞ –ø–æ—Å—Ç—É: –æ–Ω –¥–æ–ª–∂–µ–Ω –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –Ω–∞–∂–∏–º–∞—Ç—å –∫–Ω–æ–ø–∫—É "–Ø –∑–¥–µ—Å—å", —á—Ç–æ–±—ã —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –ø—É–ª—å—Ç –∑–Ω–∞–ª, —á—Ç–æ –æ–Ω –Ω–µ —É—Å–Ω—É–ª. –ï—Å–ª–∏ —Å–∏–≥–Ω–∞–ª –Ω–µ –ø—Ä–∏—Ö–æ–¥–∏—Ç ‚Äî —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç—Ä–µ–≤–æ–≥–∞. –í —Å–µ—Ç–µ–≤—ã—Ö –ø—Ä–æ—Ç–æ–∫–æ–ª–∞—Ö —ç—Ç–∞ –∫–Ω–æ–ø–∫–∞ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è **Ping**, –∞ –æ—Ç–≤–µ—Ç ‚Äî **Pong**.

–í —Ä–µ–∞–ª—å–Ω–æ–º —Ç—Ä–µ–π–¥–∏–Ω–≥–µ ping-pong –º–µ—Ö–∞–Ω–∏–∑–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–µ–Ω:
- **–ë–∏—Ä–∂–∏ –æ—Ç–∫–ª—é—á–∞—é—Ç –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è** —á–µ—Ä–µ–∑ 30-60 —Å–µ–∫—É–Ω–¥ –±–µ–∑ –ø–∏–Ω–≥–∞
- **–¢—ã –¥–æ–ª–∂–µ–Ω –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É** ‚Äî –µ—Å–ª–∏ pong –ø—Ä–∏—Ö–æ–¥–∏—Ç —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ, –≤–æ–∑–º–æ–∂–Ω–æ, —Å–µ—Ç—å –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–∞
- **–ü—Ä–∏ –æ–±—Ä—ã–≤–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è** –Ω—É–∂–Ω–æ –±—ã—Å—Ç—Ä–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Å–¥–µ–ª–∫–∏

## –ß—Ç–æ —Ç–∞–∫–æ–µ Ping-Pong?

Ping-Pong ‚Äî —ç—Ç–æ –º–µ—Ö–∞–Ω–∏–∑–º **heartbeat** (—Å–µ—Ä–¥—Ü–µ–±–∏–µ–Ω–∏–µ) –¥–ª—è TCP/WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π:

1. **Ping** ‚Äî —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ —Å–µ—Ä–≤–µ—Ä—É: "–¢—ã –µ—â—ë —Ç–∞–º?"
2. **Pong** ‚Äî –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞: "–î–∞, —è –∑–¥–µ—Å—å!"

```
–ö–ª–∏–µ–Ω—Ç                          –°–µ—Ä–≤–µ—Ä
   |                               |
   |-------- PING --------------->|
   |                               |
   |<------- PONG ----------------|
   |                               |
   |-------- PING --------------->|
   |                               |
   |<------- PONG ----------------|
   |                               |
   ...
```

### –ó–∞—á–µ–º –Ω—É–∂–µ–Ω Ping-Pong?

| –ü—Ä–æ–±–ª–µ–º–∞ | –†–µ—à–µ–Ω–∏–µ —Å Ping-Pong |
|----------|---------------------|
| –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ "–∑–∞–≤–∏—Å–ª–æ" | –¢–∞–π–º–∞—É—Ç –Ω–∞ pong ‚Äî –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ |
| –°–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω | –£–≤–µ–ª–∏—á–µ–Ω–∏–µ latency –ø–∏–Ω–≥–æ–≤ ‚Äî –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ |
| NAT/Firewall –∑–∞–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ | –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø–∏–Ω–≥–∏ –¥–µ—Ä–∂–∞—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã–º |
| –°–±–æ–π –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ —Å–µ—Ä–≤–µ—Ä–∞ | –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ pong = –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è |

## –ü—Ä–æ—Å—Ç–æ–π Ping-Pong —Å TCP

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::time::{interval, timeout, Duration};
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Debug)]
struct ConnectionStats {
    pings_sent: u64,
    pongs_received: u64,
    last_latency_ms: u64,
}

// –°–µ—Ä–≤–µ—Ä: –æ—Ç–≤–µ—á–∞–µ—Ç PONG –Ω–∞ –∫–∞–∂–¥—ã–π PING
async fn run_price_server() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;
    println!("–°–µ—Ä–≤–µ—Ä –∫–æ—Ç–∏—Ä–æ–≤–æ–∫ –∑–∞–ø—É—â–µ–Ω –Ω–∞ 127.0.0.1:8080");

    loop {
        let (mut socket, addr) = listener.accept().await?;
        println!("–ù–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: {}", addr);

        tokio::spawn(async move {
            let mut buffer = [0u8; 1024];

            loop {
                match socket.read(&mut buffer).await {
                    Ok(0) => {
                        println!("–ö–ª–∏–µ–Ω—Ç {} –æ—Ç–∫–ª—é—á–∏–ª—Å—è", addr);
                        break;
                    }
                    Ok(n) => {
                        let message = String::from_utf8_lossy(&buffer[..n]);

                        if message.trim() == "PING" {
                            println!("–ü–æ–ª—É—á–µ–Ω PING –æ—Ç {}", addr);
                            if let Err(e) = socket.write_all(b"PONG\n").await {
                                eprintln!("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ PONG: {}", e);
                                break;
                            }
                        } else if message.starts_with("SUBSCRIBE:") {
                            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∫–æ—Ç–∏—Ä–æ–≤–∫–∏
                            let symbol = message.trim().strip_prefix("SUBSCRIBE:").unwrap();
                            println!("–ö–ª–∏–µ–Ω—Ç {} –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –Ω–∞ {}", addr, symbol);
                            socket.write_all(format!("SUBSCRIBED:{}\n", symbol).as_bytes()).await.ok();
                        }
                    }
                    Err(e) => {
                        eprintln!("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –æ—Ç {}: {}", addr, e);
                        break;
                    }
                }
            }
        });
    }
}

// –ö–ª–∏–µ–Ω—Ç: –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç PING –∏ –∂–¥—ë—Ç PONG
async fn run_trading_client() -> std::io::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    println!("–ü–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ —Å–µ—Ä–≤–µ—Ä—É –∫–æ—Ç–∏—Ä–æ–≤–æ–∫");

    let stats = Arc::new(Mutex::new(ConnectionStats {
        pings_sent: 0,
        pongs_received: 0,
        last_latency_ms: 0,
    }));

    let stats_ping = Arc::clone(&stats);

    // –ó–∞–¥–∞—á–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–∏–Ω–≥–æ–≤
    let (mut read_half, mut write_half) = stream.into_split();

    let ping_task = tokio::spawn(async move {
        let mut ping_interval = interval(Duration::from_secs(5));

        loop {
            ping_interval.tick().await;

            let start = std::time::Instant::now();

            if let Err(e) = write_half.write_all(b"PING\n").await {
                eprintln!("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ PING: {}", e);
                break;
            }

            let mut stats = stats_ping.lock().await;
            stats.pings_sent += 1;
            println!("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω PING #{}", stats.pings_sent);
        }
    });

    // –ó–∞–¥–∞—á–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–æ–≤
    let stats_pong = Arc::clone(&stats);
    let pong_task = tokio::spawn(async move {
        let mut buffer = [0u8; 1024];

        loop {
            match read_half.read(&mut buffer).await {
                Ok(0) => {
                    println!("–°–µ—Ä–≤–µ—Ä –∑–∞–∫—Ä—ã–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ");
                    break;
                }
                Ok(n) => {
                    let message = String::from_utf8_lossy(&buffer[..n]);

                    if message.trim() == "PONG" {
                        let mut stats = stats_pong.lock().await;
                        stats.pongs_received += 1;
                        println!("–ü–æ–ª—É—á–µ–Ω PONG #{}", stats.pongs_received);
                    }
                }
                Err(e) => {
                    eprintln!("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: {}", e);
                    break;
                }
            }
        }
    });

    // –ñ–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    tokio::select! {
        _ = ping_task => {},
        _ = pong_task => {},
    }

    Ok(())
}

#[tokio::main]
async fn main() {
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
    tokio::spawn(run_price_server());

    // –î–∞—ë–º —Å–µ—Ä–≤–µ—Ä—É –≤—Ä–µ–º—è –∑–∞–ø—É—Å—Ç–∏—Ç—å—Å—è
    tokio::time::sleep(Duration::from_millis(100)).await;

    // –ó–∞–ø—É—Å–∫–∞–µ–º –∫–ª–∏–µ–Ω—Ç–∞
    if let Err(e) = run_trading_client().await {
        eprintln!("–û—à–∏–±–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞: {}", e);
    }
}
```

## Ping-Pong —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏ –¥–ª—è —Ç—Ä–µ–π–¥–∏–Ω–≥–∞

–í —Ä–µ–∞–ª—å–Ω–æ–º —Ç—Ä–µ–π–¥–∏–Ω–≥–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –±—ã—Å—Ç—Ä–æ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ –ø–æ—Ç–µ—Ä—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::time::{interval, timeout, Duration, Instant};
use std::sync::Arc;
use tokio::sync::{Mutex, mpsc};

const PING_INTERVAL: Duration = Duration::from_secs(5);
const PONG_TIMEOUT: Duration = Duration::from_secs(3);
const MAX_MISSED_PONGS: u32 = 3;

#[derive(Debug, Clone)]
enum ConnectionState {
    Connected,
    Degraded { missed_pongs: u32 },
    Disconnected,
}

#[derive(Debug)]
struct ExchangeConnection {
    state: ConnectionState,
    last_pong: Instant,
    latency_ms: Vec<u64>,
}

impl ExchangeConnection {
    fn new() -> Self {
        ExchangeConnection {
            state: ConnectionState::Connected,
            last_pong: Instant::now(),
            latency_ms: Vec::new(),
        }
    }

    fn record_pong(&mut self, latency: u64) {
        self.last_pong = Instant::now();
        self.latency_ms.push(latency);

        // –•—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 –∏–∑–º–µ—Ä–µ–Ω–∏–π
        if self.latency_ms.len() > 100 {
            self.latency_ms.remove(0);
        }

        self.state = ConnectionState::Connected;
    }

    fn miss_pong(&mut self) {
        match &mut self.state {
            ConnectionState::Connected => {
                self.state = ConnectionState::Degraded { missed_pongs: 1 };
            }
            ConnectionState::Degraded { missed_pongs } => {
                *missed_pongs += 1;
                if *missed_pongs >= MAX_MISSED_PONGS {
                    self.state = ConnectionState::Disconnected;
                }
            }
            ConnectionState::Disconnected => {}
        }
    }

    fn average_latency(&self) -> Option<f64> {
        if self.latency_ms.is_empty() {
            return None;
        }
        let sum: u64 = self.latency_ms.iter().sum();
        Some(sum as f64 / self.latency_ms.len() as f64)
    }

    fn is_healthy(&self) -> bool {
        matches!(self.state, ConnectionState::Connected)
    }
}

async fn exchange_client_with_heartbeat() -> Result<(), Box<dyn std::error::Error>> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    let connection = Arc::new(Mutex::new(ExchangeConnection::new()));

    let (mut read_half, mut write_half) = stream.into_split();
    let (pong_tx, mut pong_rx) = mpsc::channel::<Instant>(10);

    // –ó–∞–¥–∞—á–∞ —á—Ç–µ–Ω–∏—è
    let read_task = tokio::spawn(async move {
        let mut buffer = [0u8; 1024];

        loop {
            match read_half.read(&mut buffer).await {
                Ok(0) => break,
                Ok(n) => {
                    let message = String::from_utf8_lossy(&buffer[..n]);
                    if message.trim() == "PONG" {
                        pong_tx.send(Instant::now()).await.ok();
                    }
                }
                Err(_) => break,
            }
        }
    });

    // –ó–∞–¥–∞—á–∞ ping-pong —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    let conn_clone = Arc::clone(&connection);
    let heartbeat_task = tokio::spawn(async move {
        let mut ping_interval = interval(PING_INTERVAL);

        loop {
            ping_interval.tick().await;

            let ping_time = Instant::now();

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º PING
            if write_half.write_all(b"PING\n").await.is_err() {
                break;
            }

            // –ñ–¥—ë–º PONG —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            match timeout(PONG_TIMEOUT, pong_rx.recv()).await {
                Ok(Some(pong_time)) => {
                    let latency = pong_time.duration_since(ping_time).as_millis() as u64;
                    let mut conn = conn_clone.lock().await;
                    conn.record_pong(latency);

                    println!(
                        "PONG –ø–æ–ª—É—á–µ–Ω: latency={}ms, avg={:.2}ms",
                        latency,
                        conn.average_latency().unwrap_or(0.0)
                    );

                    // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π –∑–∞–¥–µ—Ä–∂–∫–µ
                    if latency > 100 {
                        println!("‚ö†Ô∏è  –í—ã—Å–æ–∫–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞! –í–æ–∑–º–æ–∂–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã —Å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ–º –æ—Ä–¥–µ—Ä–æ–≤");
                    }
                }
                Ok(None) => {
                    println!("–ö–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç");
                    break;
                }
                Err(_) => {
                    let mut conn = conn_clone.lock().await;
                    conn.miss_pong();

                    match &conn.state {
                        ConnectionState::Degraded { missed_pongs } => {
                            println!(
                                "‚ö†Ô∏è  PONG –Ω–µ –ø–æ–ª—É—á–µ–Ω! –ü—Ä–æ–ø—É—â–µ–Ω–æ: {}/{}",
                                missed_pongs, MAX_MISSED_PONGS
                            );
                        }
                        ConnectionState::Disconnected => {
                            println!("‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ! –ò–Ω–∏—Ü–∏–∏—Ä—É–µ–º –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...");
                            break;
                        }
                        _ => {}
                    }
                }
            }
        }
    });

    // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    let conn_monitor = Arc::clone(&connection);
    let monitor_task = tokio::spawn(async move {
        let mut check_interval = interval(Duration::from_secs(1));

        loop {
            check_interval.tick().await;

            let conn = conn_monitor.lock().await;
            if !conn.is_healthy() {
                println!("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ–∑–¥–æ—Ä–æ–≤–æ: {:?}", conn.state);
            }
        }
    });

    tokio::select! {
        _ = read_task => println!("Read task –∑–∞–≤–µ—Ä—à—ë–Ω"),
        _ = heartbeat_task => println!("Heartbeat task –∑–∞–≤–µ—Ä—à—ë–Ω"),
        _ = monitor_task => println!("Monitor task –∑–∞–≤–µ—Ä—à—ë–Ω"),
    }

    Ok(())
}
```

## WebSocket Ping-Pong –¥–ª—è –∫—Ä–∏–ø—Ç–æ–±–∏—Ä–∂

–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –∫—Ä–∏–ø—Ç–æ–±–∏—Ä–∂ –∏—Å–ø–æ–ª—å–∑—É—é—Ç WebSocket —Å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º ping-pong:

```rust
use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures_util::{SinkExt, StreamExt};
use tokio::time::{interval, Duration, Instant};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
struct PingMessage {
    op: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    id: Option<u64>,
}

#[derive(Debug, Deserialize)]
struct PongMessage {
    op: String,
    #[serde(default)]
    id: Option<u64>,
}

#[derive(Debug, Clone)]
struct PriceUpdate {
    symbol: String,
    price: f64,
    timestamp: u64,
}

async fn binance_ws_client() -> Result<(), Box<dyn std::error::Error>> {
    // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ WebSocket API Binance
    let url = "wss://stream.binance.com:9443/ws/btcusdt@trade";

    let (ws_stream, _) = connect_async(url).await?;
    println!("–ü–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ Binance WebSocket");

    let (mut write, mut read) = ws_stream.split();

    let mut last_message_time = Instant::now();
    let mut ping_interval = interval(Duration::from_secs(30));

    loop {
        tokio::select! {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ping –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
            _ = ping_interval.tick() => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–∞–≤–Ω–æ –ª–∏ –º—ã –ø–æ–ª—É—á–∞–ª–∏ –¥–∞–Ω–Ω—ã–µ
                let silence_duration = last_message_time.elapsed();

                if silence_duration > Duration::from_secs(60) {
                    println!("‚ö†Ô∏è  –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –±–æ–ª–µ–µ 60 —Å–µ–∫—É–Ω–¥!");
                }

                // WebSocket ping (–Ω–∞ —É—Ä–æ–≤–Ω–µ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞)
                write.send(Message::Ping(vec![])).await?;
                println!("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω WebSocket PING");
            }

            // –ß–∏—Ç–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
            msg = read.next() => {
                match msg {
                    Some(Ok(Message::Text(text))) => {
                        last_message_time = Instant::now();

                        // –ü–∞—Ä—Å–∏–º —Ç–æ—Ä–≥–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
                        if let Ok(trade) = serde_json::from_str::<serde_json::Value>(&text) {
                            if let Some(price) = trade.get("p").and_then(|p| p.as_str()) {
                                println!("BTC/USDT: ${}", price);
                            }
                        }
                    }
                    Some(Ok(Message::Pong(_))) => {
                        last_message_time = Instant::now();
                        println!("–ü–æ–ª—É—á–µ–Ω PONG –æ—Ç Binance");
                    }
                    Some(Ok(Message::Ping(data))) => {
                        // –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ ping –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
                        write.send(Message::Pong(data)).await?;
                        println!("–û—Ç–≤–µ—Ç–∏–ª–∏ PONG –Ω–∞ PING –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞");
                    }
                    Some(Ok(Message::Close(_))) => {
                        println!("–°–µ—Ä–≤–µ—Ä –∑–∞–∫—Ä—ã–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ");
                        break;
                    }
                    Some(Err(e)) => {
                        eprintln!("–û—à–∏–±–∫–∞ WebSocket: {}", e);
                        break;
                    }
                    None => {
                        println!("–ü–æ—Ç–æ–∫ –∑–∞–∫—Ä—ã—Ç");
                        break;
                    }
                    _ => {}
                }
            }
        }
    }

    Ok(())
}
```

## –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ

–í —Ç—Ä–µ–π–¥–∏–Ω–≥–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –∏ –±—ã—Å—Ç—Ä—ã–º:

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::time::{sleep, timeout, Duration, Instant};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Clone, PartialEq)]
enum ConnectionStatus {
    Disconnected,
    Connecting,
    Connected,
    Reconnecting { attempt: u32 },
}

struct TradingClient {
    status: Arc<RwLock<ConnectionStatus>>,
    server_addr: String,
    max_reconnect_attempts: u32,
    base_reconnect_delay: Duration,
}

impl TradingClient {
    fn new(server_addr: &str) -> Self {
        TradingClient {
            status: Arc::new(RwLock::new(ConnectionStatus::Disconnected)),
            server_addr: server_addr.to_string(),
            max_reconnect_attempts: 10,
            base_reconnect_delay: Duration::from_secs(1),
        }
    }

    async fn connect_with_retry(&self) -> Result<TcpStream, String> {
        let mut attempt = 0;

        loop {
            attempt += 1;

            {
                let mut status = self.status.write().await;
                *status = ConnectionStatus::Reconnecting { attempt };
            }

            println!("–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è #{}", attempt);

            match timeout(
                Duration::from_secs(5),
                TcpStream::connect(&self.server_addr)
            ).await {
                Ok(Ok(stream)) => {
                    let mut status = self.status.write().await;
                    *status = ConnectionStatus::Connected;
                    println!("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ!");
                    return Ok(stream);
                }
                Ok(Err(e)) => {
                    eprintln!("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {}", e);
                }
                Err(_) => {
                    eprintln!("–¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è");
                }
            }

            if attempt >= self.max_reconnect_attempts {
                let mut status = self.status.write().await;
                *status = ConnectionStatus::Disconnected;
                return Err("–ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫".to_string());
            }

            // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —Å jitter
            let delay = self.calculate_backoff(attempt);
            println!("–°–ª–µ–¥—É—é—â–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ {:?}", delay);
            sleep(delay).await;
        }
    }

    fn calculate_backoff(&self, attempt: u32) -> Duration {
        // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π backoff: 1s, 2s, 4s, 8s, ... –¥–æ 60s
        let base = self.base_reconnect_delay.as_secs_f64();
        let exp_delay = base * 2.0_f64.powi((attempt - 1) as i32);
        let capped_delay = exp_delay.min(60.0);

        // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–π jitter (¬±20%)
        let jitter = capped_delay * 0.2 * (rand::random::<f64>() - 0.5);
        Duration::from_secs_f64(capped_delay + jitter)
    }

    async fn run_with_heartbeat(self: Arc<Self>) -> Result<(), String> {
        loop {
            let stream = self.connect_with_retry().await?;
            let (mut read_half, mut write_half) = stream.into_split();

            let status = Arc::clone(&self.status);

            // Ping-pong loop
            let ping_handle = tokio::spawn(async move {
                let mut interval = tokio::time::interval(Duration::from_secs(5));
                let mut missed_pongs = 0;

                loop {
                    interval.tick().await;

                    if write_half.write_all(b"PING\n").await.is_err() {
                        return false; // –ù—É–∂–Ω–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
                    }

                    // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                    let current_status = status.read().await;
                    if !matches!(*current_status, ConnectionStatus::Connected) {
                        return false;
                    }
                }
            });

            let read_handle = tokio::spawn(async move {
                let mut buffer = [0u8; 1024];

                loop {
                    match read_half.read(&mut buffer).await {
                        Ok(0) => return false,
                        Ok(_) => {
                            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
                        }
                        Err(_) => return false,
                    }
                }
            });

            // –ñ–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ª—é–±–æ–π –∑–∞–¥–∞—á–∏
            tokio::select! {
                result = ping_handle => {
                    if let Ok(false) = result {
                        println!("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ, –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è...");
                    }
                }
                result = read_handle => {
                    if let Ok(false) = result {
                        println!("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —Å–µ—Ä–≤–µ—Ä–æ–º, –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è...");
                    }
                }
            }

            // –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º
            sleep(Duration::from_millis(500)).await;
        }
    }
}

// –ü—Ä–æ—Å—Ç–æ–π random –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ crate rand)
mod rand {
    use std::time::{SystemTime, UNIX_EPOCH};

    pub fn random<T: From<f64>>() -> T {
        let nanos = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .subsec_nanos();
        T::from((nanos % 1000) as f64 / 1000.0)
    }
}
```

## –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è

–î–ª—è –∞–ª–≥–æ—Ç—Ä–µ–π–¥–∏–Ω–≥–∞ –≤–∞–∂–Ω–æ –Ω–µ —Ç–æ–ª—å–∫–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ, –Ω–æ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å –µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–æ:

```rust
use std::collections::VecDeque;
use tokio::time::{Duration, Instant};

#[derive(Debug, Clone)]
struct LatencyStats {
    samples: VecDeque<u64>,
    max_samples: usize,
}

impl LatencyStats {
    fn new(max_samples: usize) -> Self {
        LatencyStats {
            samples: VecDeque::with_capacity(max_samples),
            max_samples,
        }
    }

    fn add_sample(&mut self, latency_ms: u64) {
        if self.samples.len() >= self.max_samples {
            self.samples.pop_front();
        }
        self.samples.push_back(latency_ms);
    }

    fn average(&self) -> Option<f64> {
        if self.samples.is_empty() {
            return None;
        }
        let sum: u64 = self.samples.iter().sum();
        Some(sum as f64 / self.samples.len() as f64)
    }

    fn percentile(&self, p: f64) -> Option<u64> {
        if self.samples.is_empty() {
            return None;
        }

        let mut sorted: Vec<u64> = self.samples.iter().copied().collect();
        sorted.sort();

        let index = ((p / 100.0) * (sorted.len() - 1) as f64).round() as usize;
        Some(sorted[index])
    }

    fn min(&self) -> Option<u64> {
        self.samples.iter().copied().min()
    }

    fn max(&self) -> Option<u64> {
        self.samples.iter().copied().max()
    }
}

#[derive(Debug)]
struct ConnectionQualityMonitor {
    latency_stats: LatencyStats,
    missed_pongs: u32,
    total_pings: u64,
    total_pongs: u64,
    last_pong_time: Option<Instant>,
}

impl ConnectionQualityMonitor {
    fn new() -> Self {
        ConnectionQualityMonitor {
            latency_stats: LatencyStats::new(100),
            missed_pongs: 0,
            total_pings: 0,
            total_pongs: 0,
            last_pong_time: None,
        }
    }

    fn record_ping(&mut self) {
        self.total_pings += 1;
    }

    fn record_pong(&mut self, latency_ms: u64) {
        self.total_pongs += 1;
        self.missed_pongs = 0;
        self.last_pong_time = Some(Instant::now());
        self.latency_stats.add_sample(latency_ms);
    }

    fn record_missed_pong(&mut self) {
        self.missed_pongs += 1;
    }

    fn success_rate(&self) -> f64 {
        if self.total_pings == 0 {
            return 100.0;
        }
        (self.total_pongs as f64 / self.total_pings as f64) * 100.0
    }

    fn report(&self) -> String {
        format!(
            "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:\n\
             ‚Ä¢ –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {:.1}%\n\
             ‚Ä¢ –ü—Ä–æ–ø—É—â–µ–Ω–æ pong: {}\n\
             ‚Ä¢ Latency avg: {:.2}ms\n\
             ‚Ä¢ Latency p50: {}ms\n\
             ‚Ä¢ Latency p99: {}ms\n\
             ‚Ä¢ Latency min/max: {}/{}ms",
            self.success_rate(),
            self.missed_pongs,
            self.latency_stats.average().unwrap_or(0.0),
            self.latency_stats.percentile(50.0).unwrap_or(0),
            self.latency_stats.percentile(99.0).unwrap_or(0),
            self.latency_stats.min().unwrap_or(0),
            self.latency_stats.max().unwrap_or(0),
        )
    }

    fn should_reconnect(&self) -> bool {
        // –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è, –µ—Å–ª–∏:
        // 1. –ü—Ä–æ–ø—É—â–µ–Ω–æ 3+ pong –ø–æ–¥—Ä—è–¥
        // 2. –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –Ω–∏–∂–µ 90%
        // 3. Latency p99 > 1000ms
        self.missed_pongs >= 3
            || self.success_rate() < 90.0
            || self.latency_stats.percentile(99.0).unwrap_or(0) > 1000
    }

    fn is_suitable_for_trading(&self) -> bool {
        // –î–ª—è –∞–∫—Ç–∏–≤–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–ª–∏ –Ω—É–∂–Ω–æ:
        // 1. Latency p99 < 100ms
        // 2. –£—Å–ø–µ—à–Ω–æ—Å—Ç—å > 99%
        // 3. –ù–µ—Ç –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö pong
        self.latency_stats.percentile(99.0).unwrap_or(u64::MAX) < 100
            && self.success_rate() > 99.0
            && self.missed_pongs == 0
    }
}

fn main() {
    let mut monitor = ConnectionQualityMonitor::new();

    // –°–∏–º—É–ª—è—Ü–∏—è —Ä–∞–±–æ—Ç—ã
    for latency in [15, 18, 22, 19, 45, 21, 17, 120, 23, 19] {
        monitor.record_ping();
        monitor.record_pong(latency);
    }

    println!("{}", monitor.report());
    println!("\n–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏: {}", monitor.is_suitable_for_trading());
}
```

## –ß—Ç–æ –º—ã —É–∑–Ω–∞–ª–∏

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –û–ø–∏—Å–∞–Ω–∏–µ |
|-----------|----------|
| Ping-Pong | –ú–µ—Ö–∞–Ω–∏–∑–º heartbeat –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∂–∏–≤–æ—Å—Ç–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è |
| –¢–∞–π–º–∞—É—Ç pong | –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ ping |
| –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π backoff | –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è |
| Jitter | –°–ª—É—á–∞–π–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è thundering herd |
| Latency –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ | –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è |
| –ê–≤—Ç–æ–ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ | –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è |

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è

1. **–ë–∞–∑–æ–≤—ã–π heartbeat**: –†–µ–∞–ª–∏–∑—É–π –ø—Ä–æ—Å—Ç–æ–π TCP-—Å–µ—Ä–≤–µ—Ä –∏ –∫–ª–∏–µ–Ω—Ç —Å ping-pong –º–µ—Ö–∞–Ω–∏–∑–º–æ–º. –°–µ—Ä–≤–µ—Ä –¥–æ–ª–∂–µ–Ω –æ—Ç–∫–ª—é—á–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–æ–≤, –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–≤—à–∏—Ö ping –±–æ–ª–µ–µ 30 —Å–µ–∫—É–Ω–¥.

2. **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ latency**: –î–æ–±–∞–≤—å –∫ –∫–ª–∏–µ–Ω—Ç—É —Å–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞–¥–µ—Ä–∂–∫–∏ –∏ –≤—ã–≤–æ–¥ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è, –µ—Å–ª–∏ p95 latency –ø—Ä–µ–≤—ã—à–∞–µ—Ç 100ms.

3. **–£–º–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ**: –†–µ–∞–ª–∏–∑—É–π –∫–ª–∏–µ–Ω—Ç–∞ —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–º backoff –∏ jitter. –î–æ–±–∞–≤—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è.

4. **–ú—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ**: –°–æ–∑–¥–∞–π –∫–ª–∏–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –±–∏—Ä–∂–∞–º–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –∫–∞–∂–¥–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –æ—Ç–¥–µ–ª—å–Ω–æ.

## –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ

1. **–°–∏–º—É–ª—è—Ç–æ—Ä –±–∏—Ä–∂–µ–≤–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è**: –°–æ–∑–¥–∞–π –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è:
   - –ü–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ "—Å–µ—Ä–≤–µ—Ä—É –∫–æ—Ç–∏—Ä–æ–≤–æ–∫" (–º–æ–∂–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–≤–æ–π TCP-—Å–µ—Ä–≤–µ—Ä)
   - –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç ping –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
   - –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç latency –∏ –≤—ã–≤–æ–¥–∏—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è

2. **–î–µ—Ç–µ–∫—Ç–æ—Ä –ø—Ä–æ–±–ª–µ–º —Å–µ—Ç–∏**: –†–∞—Å—à–∏—Ä—å –ø—Ä–æ–≥—Ä–∞–º–º—É –∏–∑ –∑–∞–¥–∞–Ω–∏—è 1:
   - –î–æ–±–∞–≤—å –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ "—Ç–∏—Ö–∏—Ö" –æ–±—Ä—ã–≤–æ–≤ (–∫–æ–≥–¥–∞ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Å—Ç–∞—é—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å)
   - –†–µ–∞–ª–∏–∑—É–π –∞–ª–µ—Ä—Ç—ã –ø—Ä–∏ –¥–µ–≥—Ä–∞–¥–∞—Ü–∏–∏ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
   - –î–æ–±–∞–≤—å –ª–æ–≥ –≤—Å–µ—Ö –ø—Ä–æ–±–ª–µ–º –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞

3. **–ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤—â–∏–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π**: –°–æ–∑–¥–∞–π –∫–ª–∏–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π:
   - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º —Å–µ—Ä–≤–µ—Ä–∞–º
   - –í—ã–±–∏—Ä–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä —Å –Ω–∞–∏–º–µ–Ω—å—à–µ–π latency –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ä–¥–µ—Ä–æ–≤
   - –ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç—Å—è –Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏ –ø—Ä–æ–±–ª–µ–º–∞—Ö —Å –æ—Å–Ω–æ–≤–Ω—ã–º

4. **–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏**: –ù–∞–ø–∏—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è:
   - –°–æ–±–∏—Ä–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É ping-pong –∑–∞ –¥–ª–∏—Ç–µ–ª—å–Ω—ã–π –ø–µ—Ä–∏–æ–¥
   - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–µ–≥—Ä–∞–¥–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ–±–ª–µ–º—ã –≤ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –≤—Ä–µ–º—è —Å—É—Ç–æ–∫)
   - –í—ã–≤–æ–¥–∏—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è

## –ù–∞–≤–∏–≥–∞—Ü–∏—è

[‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å](../205-websocket-streaming-data/ru.md) | [–°–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å ‚Üí](../207-graceful-shutdown/ru.md)
