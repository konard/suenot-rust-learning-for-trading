# Ğ”ĞµĞ½ÑŒ 212: ĞŸÑ€Ğ¾ĞµĞºÑ‚: Real-time Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€ Ñ†ĞµĞ½

## ĞĞ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ Ğ¸Ğ· Ñ‚Ñ€ĞµĞ¹Ğ´Ğ¸Ğ½Ğ³Ğ°

ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²ÑŒ ÑĞµĞ±Ğµ Ñ‚Ñ€ĞµĞ¹Ğ´ĞµÑ€Ğ°, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑĞ»ĞµĞ´Ğ¸Ñ‚ Ğ·Ğ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ğ¼Ğ¸ Ğ±Ğ¸Ñ€Ğ¶Ğ°Ğ¼Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾. Ğ£ Ğ½ĞµĞ³Ğ¾ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¾Ğ²: Ğ½Ğ° Ğ¾Ğ´Ğ½Ğ¾Ğ¼ â€” Ñ†ĞµĞ½Ñ‹ Ğ½Ğ° Binance, Ğ½Ğ° Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¼ â€” Coinbase, Ğ½Ğ° Ñ‚Ñ€ĞµÑ‚ÑŒĞµĞ¼ â€” Kraken. ĞĞ½ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ Ñ†ĞµĞ½Ñ‹ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸, Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ñ€ĞµĞ·ĞºĞ¸Ñ… Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸ÑÑ… Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾ Ñ€ĞµĞ°Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ° Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ°Ñ€Ğ±Ğ¸Ñ‚Ñ€Ğ°Ğ¶Ğ°.

ĞĞ°Ñˆ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚ â€” ÑÑ‚Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğ¹ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€ Ñ†ĞµĞ½. ĞœÑ‹ Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½Ğ¸Ğ¼ Ğ²ÑĞµ Ğ·Ğ½Ğ°Ğ½Ğ¸Ñ Ğ¼ĞµÑÑÑ†Ğ°: async/await, tokio, WebSocket, HTTP Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹, ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ¸ graceful shutdown â€” Ğ² Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° Ñ†ĞµĞ½ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸.

## ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Real-time Price Monitor                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   Binance    â”‚   â”‚   Coinbase   â”‚   â”‚   Mock API   â”‚        â”‚
â”‚  â”‚  WebSocket   â”‚   â”‚   HTTP API   â”‚   â”‚  (fallback)  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚         â”‚                  â”‚                  â”‚                 â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                  â”‚                   â”‚                          â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚         â”‚         Price Aggregator             â”‚                 â”‚
â”‚         â”‚    (broadcast channel sender)        â”‚                 â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                          â”‚                                       â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚         â”‚                â”‚                â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚   Console   â”‚  â”‚    Alert    â”‚  â”‚  Statistics â”‚             â”‚
â”‚  â”‚   Display   â”‚  â”‚   Service   â”‚  â”‚   Tracker   â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              Graceful Shutdown Handler                      â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°

```toml
# Cargo.toml
[package]
name = "price-monitor"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
tokio-tungstenite = { version = "0.21", features = ["native-tls"] }
futures-util = "0.3"
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
chrono = { version = "0.4", features = ["serde"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
url = "2"
```

## ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº Ñ†ĞµĞ½Ñ‹
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PriceSource {
    Binance,
    Coinbase,
    Mock,
}

impl std::fmt::Display for PriceSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PriceSource::Binance => write!(f, "Binance"),
            PriceSource::Coinbase => write!(f, "Coinbase"),
            PriceSource::Mock => write!(f, "Mock"),
        }
    }
}

/// ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Ğ¾Ñ‚ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ°
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceUpdate {
    pub symbol: String,
    pub price: f64,
    pub source: PriceSource,
    pub timestamp: DateTime<Utc>,
    pub volume_24h: Option<f64>,
}

impl PriceUpdate {
    pub fn new(symbol: String, price: f64, source: PriceSource) -> Self {
        Self {
            symbol,
            price,
            source,
            timestamp: Utc::now(),
            volume_24h: None,
        }
    }

    pub fn with_volume(mut self, volume: f64) -> Self {
        self.volume_24h = Some(volume);
        self
    }
}

/// ĞĞ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ğµ Ğ¾ Ñ†ĞµĞ½Ğ¾Ğ²Ğ¾Ğ¼ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¸
#[derive(Debug, Clone)]
pub struct PriceAlert {
    pub symbol: String,
    pub alert_type: AlertType,
    pub current_price: f64,
    pub threshold: f64,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub enum AlertType {
    PriceAbove,
    PriceBelow,
    PercentageChange { change_percent: f64 },
    ArbitrageOpportunity { low_source: PriceSource, high_source: PriceSource },
}

/// Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ
#[derive(Debug, Clone, Default)]
pub struct PriceStatistics {
    pub symbol: String,
    pub high_24h: f64,
    pub low_24h: f64,
    pub avg_price: f64,
    pub update_count: u64,
    pub last_update: Option<DateTime<Utc>>,
    pub prices_by_source: HashMap<PriceSource, f64>,
}

impl PriceStatistics {
    pub fn new(symbol: String) -> Self {
        Self {
            symbol,
            high_24h: f64::MIN,
            low_24h: f64::MAX,
            ..Default::default()
        }
    }

    pub fn update(&mut self, price_update: &PriceUpdate) {
        self.high_24h = self.high_24h.max(price_update.price);
        self.low_24h = self.low_24h.min(price_update.price);
        self.update_count += 1;

        // ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğµ ÑĞºĞ¾Ğ»ÑŒĞ·ÑÑ‰ĞµĞµ ÑÑ€ĞµĞ´Ğ½ĞµĞµ
        let old_sum = self.avg_price * (self.update_count - 1) as f64;
        self.avg_price = (old_sum + price_update.price) / self.update_count as f64;

        self.last_update = Some(price_update.timestamp);
        self.prices_by_source.insert(price_update.source.clone(), price_update.price);
    }

    /// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ°Ñ€Ğ±Ğ¸Ñ‚Ñ€Ğ°Ğ¶Ğ° Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ±Ğ¸Ñ€Ğ¶Ğ°Ğ¼Ğ¸
    pub fn check_arbitrage(&self, min_spread_percent: f64) -> Option<(PriceSource, PriceSource, f64)> {
        if self.prices_by_source.len() < 2 {
            return None;
        }

        let mut min_price = f64::MAX;
        let mut max_price = f64::MIN;
        let mut min_source = None;
        let mut max_source = None;

        for (source, &price) in &self.prices_by_source {
            if price < min_price {
                min_price = price;
                min_source = Some(source.clone());
            }
            if price > max_price {
                max_price = price;
                max_source = Some(source.clone());
            }
        }

        let spread_percent = (max_price - min_price) / min_price * 100.0;

        if spread_percent >= min_spread_percent {
            Some((min_source.unwrap(), max_source.unwrap(), spread_percent))
        } else {
            None
        }
    }
}
```

## WebSocket ĞºĞ»Ğ¸ĞµĞ½Ñ‚ Ğ´Ğ»Ñ Binance

```rust
use futures_util::{SinkExt, StreamExt};
use tokio::sync::broadcast;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{error, info, warn};

/// ĞšĞ»Ğ¸ĞµĞ½Ñ‚ WebSocket Ğ´Ğ»Ñ Binance
pub struct BinanceWebSocket {
    symbols: Vec<String>,
    price_sender: broadcast::Sender<PriceUpdate>,
}

impl BinanceWebSocket {
    pub fn new(symbols: Vec<String>, price_sender: broadcast::Sender<PriceUpdate>) -> Self {
        Self { symbols, price_sender }
    }

    /// Ğ—Ğ°Ğ¿ÑƒÑĞº WebSocket Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼ Ñ€ĞµĞºĞ¾Ğ½Ğ½ĞµĞºÑ‚Ğ¾Ğ¼
    pub async fn run(&self, mut shutdown: broadcast::Receiver<()>) {
        loop {
            tokio::select! {
                _ = shutdown.recv() => {
                    info!("Binance WebSocket: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸");
                    break;
                }
                result = self.connect_and_listen() => {
                    match result {
                        Ok(_) => {
                            info!("Binance WebSocket: ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¾ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾");
                        }
                        Err(e) => {
                            error!("Binance WebSocket: Ğ¾ÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ: {}", e);
                        }
                    }
                    // Ğ ĞµĞºĞ¾Ğ½Ğ½ĞµĞºÑ‚ Ñ‡ĞµÑ€ĞµĞ· 5 ÑĞµĞºÑƒĞ½Ğ´
                    info!("Binance WebSocket: Ñ€ĞµĞºĞ¾Ğ½Ğ½ĞµĞºÑ‚ Ñ‡ĞµÑ€ĞµĞ· 5 ÑĞµĞºÑƒĞ½Ğ´...");
                    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                }
            }
        }
    }

    async fn connect_and_listen(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ URL Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ½Ğ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
        let streams: Vec<String> = self.symbols
            .iter()
            .map(|s| format!("{}@trade", s.to_lowercase()))
            .collect();

        let url = format!(
            "wss://stream.binance.com:9443/stream?streams={}",
            streams.join("/")
        );

        info!("Binance WebSocket: Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº {}", url);

        let (ws_stream, _) = connect_async(&url).await?;
        let (mut write, mut read) = ws_stream.split();

        info!("Binance WebSocket: Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾!");

        // ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ ping Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»
        let ping_interval = tokio::time::interval(tokio::time::Duration::from_secs(30));
        tokio::pin!(ping_interval);

        loop {
            tokio::select! {
                // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ping ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 30 ÑĞµĞºÑƒĞ½Ğ´
                _ = ping_interval.tick() => {
                    write.send(Message::Ping(vec![])).await?;
                }

                // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
                message = read.next() => {
                    match message {
                        Some(Ok(Message::Text(text))) => {
                            if let Err(e) = self.process_message(&text) {
                                warn!("Binance: Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ: {}", e);
                            }
                        }
                        Some(Ok(Message::Pong(_))) => {
                            // Pong Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½, ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¶Ğ¸Ğ²Ğ¾
                        }
                        Some(Ok(Message::Close(_))) => {
                            info!("Binance WebSocket: ÑĞµÑ€Ğ²ĞµÑ€ Ğ·Ğ°ĞºÑ€Ñ‹Ğ» ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ");
                            break;
                        }
                        Some(Err(e)) => {
                            error!("Binance WebSocket: Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {}", e);
                            break;
                        }
                        None => {
                            info!("Binance WebSocket: Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½");
                            break;
                        }
                        _ => {}
                    }
                }
            }
        }

        Ok(())
    }

    fn process_message(&self, text: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        #[derive(Deserialize)]
        struct BinanceStreamMessage {
            stream: String,
            data: BinanceTradeData,
        }

        #[derive(Deserialize)]
        struct BinanceTradeData {
            #[serde(rename = "s")]
            symbol: String,
            #[serde(rename = "p")]
            price: String,
            #[serde(rename = "q")]
            quantity: String,
        }

        let msg: BinanceStreamMessage = serde_json::from_str(text)?;
        let price: f64 = msg.data.price.parse()?;
        let volume: f64 = msg.data.quantity.parse()?;

        let update = PriceUpdate::new(
            msg.data.symbol,
            price,
            PriceSource::Binance,
        ).with_volume(volume);

        // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ°Ğ¼
        let _ = self.price_sender.send(update);

        Ok(())
    }
}
```

## HTTP ĞºĞ»Ğ¸ĞµĞ½Ñ‚ Ğ´Ğ»Ñ Coinbase

```rust
use reqwest::Client;
use std::time::Duration;
use tokio::sync::broadcast;
use tracing::{error, info, warn};

/// HTTP ĞºĞ»Ğ¸ĞµĞ½Ñ‚ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½ Ñ Coinbase
pub struct CoinbaseHttpClient {
    client: Client,
    symbols: Vec<String>,
    price_sender: broadcast::Sender<PriceUpdate>,
    poll_interval: Duration,
}

impl CoinbaseHttpClient {
    pub fn new(
        symbols: Vec<String>,
        price_sender: broadcast::Sender<PriceUpdate>,
        poll_interval: Duration,
    ) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(10))
            .build()
            .expect("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ HTTP ĞºĞ»Ğ¸ĞµĞ½Ñ‚");

        Self {
            client,
            symbols,
            price_sender,
            poll_interval,
        }
    }

    pub async fn run(&self, mut shutdown: broadcast::Receiver<()>) {
        let mut interval = tokio::time::interval(self.poll_interval);

        loop {
            tokio::select! {
                _ = shutdown.recv() => {
                    info!("Coinbase HTTP: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸");
                    break;
                }
                _ = interval.tick() => {
                    self.fetch_all_prices().await;
                }
            }
        }
    }

    async fn fetch_all_prices(&self) {
        for symbol in &self.symbols {
            match self.fetch_price(symbol).await {
                Ok(update) => {
                    let _ = self.price_sender.send(update);
                }
                Err(e) => {
                    warn!("Coinbase: Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½Ñ‹ {}: {}", symbol, e);
                }
            }
        }
    }

    async fn fetch_price(&self, symbol: &str) -> Result<PriceUpdate, Box<dyn std::error::Error + Send + Sync>> {
        #[derive(Deserialize)]
        struct CoinbaseTickerResponse {
            price: String,
            volume: String,
        }

        // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» (BTCUSDT -> BTC-USD)
        let product_id = self.convert_symbol(symbol);
        let url = format!("https://api.coinbase.com/v2/prices/{}/spot", product_id);

        let response = self.client
            .get(&url)
            .send()
            .await?;

        #[derive(Deserialize)]
        struct CoinbaseResponse {
            data: CoinbaseData,
        }

        #[derive(Deserialize)]
        struct CoinbaseData {
            amount: String,
        }

        let data: CoinbaseResponse = response.json().await?;
        let price: f64 = data.data.amount.parse()?;

        Ok(PriceUpdate::new(
            symbol.to_string(),
            price,
            PriceSource::Coinbase,
        ))
    }

    fn convert_symbol(&self, symbol: &str) -> String {
        // ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğµ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ BTCUSDT -> BTC-USD
        if symbol.ends_with("USDT") {
            let base = symbol.trim_end_matches("USDT");
            format!("{}-USD", base)
        } else {
            symbol.to_string()
        }
    }
}
```

## Mock API Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

```rust
use rand::Rng;
use std::time::Duration;
use tokio::sync::broadcast;
use tracing::info;

/// Mock Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº Ñ†ĞµĞ½ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±ĞµĞ· Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ API
pub struct MockPriceSource {
    symbols: Vec<(String, f64)>, // (ÑĞ¸Ğ¼Ğ²Ğ¾Ğ», Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ñ†ĞµĞ½Ğ°)
    price_sender: broadcast::Sender<PriceUpdate>,
    update_interval: Duration,
}

impl MockPriceSource {
    pub fn new(
        symbols: Vec<(String, f64)>,
        price_sender: broadcast::Sender<PriceUpdate>,
        update_interval: Duration,
    ) -> Self {
        Self {
            symbols,
            price_sender,
            update_interval,
        }
    }

    pub async fn run(&self, mut shutdown: broadcast::Receiver<()>) {
        let mut interval = tokio::time::interval(self.update_interval);
        let mut rng = rand::thread_rng();

        info!("Mock Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº Ñ†ĞµĞ½ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½");

        loop {
            tokio::select! {
                _ = shutdown.recv() => {
                    info!("Mock: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸");
                    break;
                }
                _ = interval.tick() => {
                    for (symbol, base_price) in &self.symbols {
                        // Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ¾Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Â±2%
                        let change: f64 = rng.gen_range(-0.02..0.02);
                        let price = base_price * (1.0 + change);
                        let volume: f64 = rng.gen_range(0.1..10.0);

                        let update = PriceUpdate::new(
                            symbol.clone(),
                            price,
                            PriceSource::Mock,
                        ).with_volume(volume);

                        let _ = self.price_sender.send(update);
                    }
                }
            }
        }
    }
}
```

## Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ğ¹

```rust
use std::collections::HashMap;
use tokio::sync::broadcast;
use tracing::info;

/// ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ñ
#[derive(Debug, Clone)]
pub struct AlertConfig {
    pub symbol: String,
    pub price_above: Option<f64>,
    pub price_below: Option<f64>,
    pub percent_change_threshold: Option<f64>,
}

/// Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ğ¹
pub struct AlertService {
    configs: Vec<AlertConfig>,
    last_prices: HashMap<String, f64>,
    alert_sender: broadcast::Sender<PriceAlert>,
}

impl AlertService {
    pub fn new(configs: Vec<AlertConfig>, alert_sender: broadcast::Sender<PriceAlert>) -> Self {
        Self {
            configs,
            last_prices: HashMap::new(),
            alert_sender,
        }
    }

    pub async fn run(&mut self, mut price_receiver: broadcast::Receiver<PriceUpdate>, mut shutdown: broadcast::Receiver<()>) {
        info!("Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½");

        loop {
            tokio::select! {
                _ = shutdown.recv() => {
                    info!("AlertService: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸");
                    break;
                }
                result = price_receiver.recv() => {
                    match result {
                        Ok(update) => self.check_alerts(&update),
                        Err(broadcast::error::RecvError::Lagged(n)) => {
                            info!("AlertService: Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾ {} ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹", n);
                        }
                        Err(broadcast::error::RecvError::Closed) => {
                            info!("AlertService: ĞºĞ°Ğ½Ğ°Ğ» Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚");
                            break;
                        }
                    }
                }
            }
        }
    }

    fn check_alerts(&mut self, update: &PriceUpdate) {
        for config in &self.configs {
            if config.symbol != update.symbol {
                continue;
            }

            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€ĞµĞ²Ñ‹ÑˆĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ñ€Ğ¾Ğ³Ğ°
            if let Some(threshold) = config.price_above {
                if update.price > threshold {
                    self.send_alert(PriceAlert {
                        symbol: update.symbol.clone(),
                        alert_type: AlertType::PriceAbove,
                        current_price: update.price,
                        threshold,
                        timestamp: update.timestamp,
                    });
                }
            }

            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ½Ğ¸Ğ¶Ğµ Ğ¿Ğ¾Ñ€Ğ¾Ğ³Ğ°
            if let Some(threshold) = config.price_below {
                if update.price < threshold {
                    self.send_alert(PriceAlert {
                        symbol: update.symbol.clone(),
                        alert_type: AlertType::PriceBelow,
                        current_price: update.price,
                        threshold,
                        timestamp: update.timestamp,
                    });
                }
            }

            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
            if let Some(percent_threshold) = config.percent_change_threshold {
                if let Some(&last_price) = self.last_prices.get(&update.symbol) {
                    let change_percent = (update.price - last_price) / last_price * 100.0;

                    if change_percent.abs() >= percent_threshold {
                        self.send_alert(PriceAlert {
                            symbol: update.symbol.clone(),
                            alert_type: AlertType::PercentageChange { change_percent },
                            current_price: update.price,
                            threshold: percent_threshold,
                            timestamp: update.timestamp,
                        });
                    }
                }
            }
        }

        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ñ†ĞµĞ½Ñƒ
        self.last_prices.insert(update.symbol.clone(), update.price);
    }

    fn send_alert(&self, alert: PriceAlert) {
        info!("ğŸš¨ ĞĞŸĞĞ’Ğ•Ğ©Ğ•ĞĞ˜Ğ•: {:?}", alert);
        let _ = self.alert_sender.send(alert);
    }
}
```

## Ğ¢Ñ€ĞµĞºĞµÑ€ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸

```rust
use std::collections::HashMap;
use tokio::sync::broadcast;
use tracing::info;

/// Ğ¢Ñ€ĞµĞºĞµÑ€ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ñ†ĞµĞ½
pub struct StatisticsTracker {
    stats: HashMap<String, PriceStatistics>,
    min_arbitrage_spread: f64,
}

impl StatisticsTracker {
    pub fn new(symbols: Vec<String>, min_arbitrage_spread: f64) -> Self {
        let mut stats = HashMap::new();
        for symbol in symbols {
            stats.insert(symbol.clone(), PriceStatistics::new(symbol));
        }
        Self { stats, min_arbitrage_spread }
    }

    pub async fn run(
        &mut self,
        mut price_receiver: broadcast::Receiver<PriceUpdate>,
        alert_sender: broadcast::Sender<PriceAlert>,
        mut shutdown: broadcast::Receiver<()>,
    ) {
        info!("Ğ¢Ñ€ĞµĞºĞµÑ€ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½");

        loop {
            tokio::select! {
                _ = shutdown.recv() => {
                    info!("StatisticsTracker: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸");
                    self.print_final_stats();
                    break;
                }
                result = price_receiver.recv() => {
                    match result {
                        Ok(update) => {
                            self.process_update(&update, &alert_sender);
                        }
                        Err(broadcast::error::RecvError::Lagged(n)) => {
                            info!("StatisticsTracker: Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾ {} ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹", n);
                        }
                        Err(broadcast::error::RecvError::Closed) => {
                            break;
                        }
                    }
                }
            }
        }
    }

    fn process_update(&mut self, update: &PriceUpdate, alert_sender: &broadcast::Sender<PriceAlert>) {
        if let Some(stats) = self.stats.get_mut(&update.symbol) {
            stats.update(update);

            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ°Ñ€Ğ±Ğ¸Ñ‚Ñ€Ğ°Ğ¶Ğ°
            if let Some((low_source, high_source, spread)) =
                stats.check_arbitrage(self.min_arbitrage_spread)
            {
                let alert = PriceAlert {
                    symbol: update.symbol.clone(),
                    alert_type: AlertType::ArbitrageOpportunity { low_source, high_source },
                    current_price: update.price,
                    threshold: spread,
                    timestamp: update.timestamp,
                };
                let _ = alert_sender.send(alert);
            }
        }
    }

    fn print_final_stats(&self) {
        println!("\nğŸ“Š Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:");
        println!("{:-<60}", "");

        for (symbol, stats) in &self.stats {
            println!("Ğ¡Ğ¸Ğ¼Ğ²Ğ¾Ğ»: {}", symbol);
            println!("  High 24h: {:.2}", stats.high_24h);
            println!("  Low 24h:  {:.2}", stats.low_24h);
            println!("  Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ:  {:.2}", stats.avg_price);
            println!("  ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹: {}", stats.update_count);
            println!("  Ğ¦ĞµĞ½Ñ‹ Ğ¿Ğ¾ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ°Ğ¼:");
            for (source, price) in &stats.prices_by_source {
                println!("    {}: {:.2}", source, price);
            }
            println!();
        }
    }

    pub fn get_stats(&self) -> &HashMap<String, PriceStatistics> {
        &self.stats
    }
}
```

## ĞšĞ¾Ğ½ÑĞ¾Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¸ÑĞ¿Ğ»ĞµĞ¹

```rust
use std::io::{self, Write};
use tokio::sync::broadcast;
use tracing::info;

/// ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»Ğ¸
pub struct ConsoleDisplay {
    update_rate: std::time::Duration,
}

impl ConsoleDisplay {
    pub fn new(update_rate: std::time::Duration) -> Self {
        Self { update_rate }
    }

    pub async fn run(
        &self,
        mut price_receiver: broadcast::Receiver<PriceUpdate>,
        mut alert_receiver: broadcast::Receiver<PriceAlert>,
        mut shutdown: broadcast::Receiver<()>,
    ) {
        info!("ĞšĞ¾Ğ½ÑĞ¾Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¸ÑĞ¿Ğ»ĞµĞ¹ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½");

        let mut last_prices: std::collections::HashMap<(String, PriceSource), PriceUpdate> =
            std::collections::HashMap::new();
        let mut interval = tokio::time::interval(self.update_rate);

        loop {
            tokio::select! {
                _ = shutdown.recv() => {
                    info!("ConsoleDisplay: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸");
                    break;
                }

                // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½
                result = price_receiver.recv() => {
                    match result {
                        Ok(update) => {
                            let key = (update.symbol.clone(), update.source.clone());
                            last_prices.insert(key, update);
                        }
                        Err(broadcast::error::RecvError::Lagged(_)) => {}
                        Err(broadcast::error::RecvError::Closed) => break,
                    }
                }

                // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ñ
                result = alert_receiver.recv() => {
                    if let Ok(alert) = result {
                        self.display_alert(&alert);
                    }
                }

                // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ´Ğ¸ÑĞ¿Ğ»ĞµĞ¹
                _ = interval.tick() => {
                    self.render(&last_prices);
                }
            }
        }
    }

    fn render(&self, prices: &std::collections::HashMap<(String, PriceSource), PriceUpdate>) {
        // ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ ÑĞºÑ€Ğ°Ğ½ (ANSI escape code)
        print!("\x1B[2J\x1B[1;1H");

        println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println!("â•‘           ğŸ’° Real-time Price Monitor ğŸ’°                    â•‘");
        println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        println!("â•‘ {:^10} â”‚ {:^12} â”‚ {:^12} â”‚ {:^18} â•‘",
                 "Ğ¡Ğ¸Ğ¼Ğ²Ğ¾Ğ»", "Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº", "Ğ¦ĞµĞ½Ğ°", "Ğ’Ñ€ĞµĞ¼Ñ");
        println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");

        let mut sorted_prices: Vec<_> = prices.values().collect();
        sorted_prices.sort_by(|a, b| a.symbol.cmp(&b.symbol));

        for update in sorted_prices {
            let time_str = update.timestamp.format("%H:%M:%S").to_string();
            println!("â•‘ {:^10} â”‚ {:^12} â”‚ {:>12.2} â”‚ {:^18} â•‘",
                     update.symbol,
                     update.source.to_string(),
                     update.price,
                     time_str);
        }

        println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        println!("\nĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ctrl+C Ğ´Ğ»Ñ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ°...");

        io::stdout().flush().unwrap();
    }

    fn display_alert(&self, alert: &PriceAlert) {
        let alert_msg = match &alert.alert_type {
            AlertType::PriceAbove => {
                format!("â¬†ï¸  {} Ğ¿Ñ€ĞµĞ²Ñ‹ÑĞ¸Ğ» {:.2}! Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ: {:.2}",
                        alert.symbol, alert.threshold, alert.current_price)
            }
            AlertType::PriceBelow => {
                format!("â¬‡ï¸  {} ÑƒĞ¿Ğ°Ğ» Ğ½Ğ¸Ğ¶Ğµ {:.2}! Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ: {:.2}",
                        alert.symbol, alert.threshold, alert.current_price)
            }
            AlertType::PercentageChange { change_percent } => {
                let arrow = if *change_percent > 0.0 { "ğŸ“ˆ" } else { "ğŸ“‰" };
                format!("{} {} Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ Ğ½Ğ° {:.2}%! Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ: {:.2}",
                        arrow, alert.symbol, change_percent, alert.current_price)
            }
            AlertType::ArbitrageOpportunity { low_source, high_source } => {
                format!("ğŸ’ ĞĞ Ğ‘Ğ˜Ğ¢Ğ ĞĞ– {}! ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ½Ğ° {}, Ğ¿Ñ€Ğ¾Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ° {}. Ğ¡Ğ¿Ñ€ĞµĞ´: {:.2}%",
                        alert.symbol, low_source, high_source, alert.threshold)
            }
        };

        println!("\nğŸš¨ {}", alert_msg);
    }
}
```

## Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ

```rust
use std::time::Duration;
use tokio::sync::broadcast;
use tracing::info;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ñ‹ Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ (Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğµ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ°Ñ…)
mod types;
mod binance_ws;
mod coinbase_http;
mod mock_source;
mod alert_service;
mod statistics;
mod display;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(tracing_subscriber::EnvFilter::from_default_env()
            .add_directive("price_monitor=info".parse()?))
        .init();

    info!("ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº Real-time Price Monitor");

    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ¼ÑƒĞ½Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
    let (price_tx, _) = broadcast::channel::<PriceUpdate>(1000);
    let (alert_tx, _) = broadcast::channel::<PriceAlert>(100);
    let (shutdown_tx, _) = broadcast::channel::<()>(1);

    // Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ
    let symbols = vec![
        "BTCUSDT".to_string(),
        "ETHUSDT".to_string(),
        "BNBUSDT".to_string(),
    ];

    // ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ğ¹
    let alert_configs = vec![
        AlertConfig {
            symbol: "BTCUSDT".to_string(),
            price_above: Some(100000.0),
            price_below: Some(90000.0),
            percent_change_threshold: Some(1.0),
        },
        AlertConfig {
            symbol: "ETHUSDT".to_string(),
            price_above: Some(4000.0),
            price_below: Some(3000.0),
            percent_change_threshold: Some(2.0),
        },
    ];

    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Mock Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº (Ğ´Ğ»Ñ Ğ´ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸)
    let mock_symbols = vec![
        ("BTCUSDT".to_string(), 95000.0),
        ("ETHUSDT".to_string(), 3500.0),
        ("BNBUSDT".to_string(), 600.0),
    ];
    let mock_source = MockPriceSource::new(
        mock_symbols,
        price_tx.clone(),
        Duration::from_millis(500),
    );

    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ÑĞµÑ€Ğ²Ğ¸Ñ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ğ¹
    let mut alert_service = AlertService::new(
        alert_configs,
        alert_tx.clone(),
    );

    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ñ‚Ñ€ĞµĞºĞµÑ€ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
    let mut stats_tracker = StatisticsTracker::new(
        symbols.clone(),
        0.5, // ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¿Ñ€ĞµĞ´ Ğ´Ğ»Ñ Ğ°Ñ€Ğ±Ğ¸Ñ‚Ñ€Ğ°Ğ¶Ğ° 0.5%
    );

    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¸ÑĞ¿Ğ»ĞµĞ¹
    let console_display = ConsoleDisplay::new(Duration::from_millis(200));

    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ²ÑĞµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
    let mock_handle = tokio::spawn({
        let shutdown_rx = shutdown_tx.subscribe();
        async move {
            mock_source.run(shutdown_rx).await;
        }
    });

    let alert_handle = tokio::spawn({
        let price_rx = price_tx.subscribe();
        let shutdown_rx = shutdown_tx.subscribe();
        async move {
            alert_service.run(price_rx, shutdown_rx).await;
        }
    });

    let stats_handle = tokio::spawn({
        let price_rx = price_tx.subscribe();
        let alert_tx_clone = alert_tx.clone();
        let shutdown_rx = shutdown_tx.subscribe();
        async move {
            stats_tracker.run(price_rx, alert_tx_clone, shutdown_rx).await;
        }
    });

    let display_handle = tokio::spawn({
        let price_rx = price_tx.subscribe();
        let alert_rx = alert_tx.subscribe();
        let shutdown_rx = shutdown_tx.subscribe();
        async move {
            console_display.run(price_rx, alert_rx, shutdown_rx).await;
        }
    });

    // ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ (Ctrl+C)
    tokio::signal::ctrl_c().await?;

    info!("ğŸ“´ ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ, Ğ¾ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞµÑ€Ğ²Ğ¸ÑÑ‹...");

    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸ Ğ²ÑĞµĞ¼ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ°Ğ¼
    let _ = shutdown_tx.send(());

    // Ğ”Ğ°Ñ‘Ğ¼ Ğ²Ñ€ĞµĞ¼Ñ Ğ½Ğ° graceful shutdown
    tokio::time::sleep(Duration::from_secs(1)).await;

    // ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ²ÑĞµÑ… Ğ·Ğ°Ğ´Ğ°Ñ‡
    let _ = tokio::join!(mock_handle, alert_handle, stats_handle, display_handle);

    info!("âœ… Price Monitor Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½");

    Ok(())
}
```

## Ğ§Ñ‚Ğ¾ Ğ¼Ñ‹ Ğ¸Ğ·ÑƒÑ‡Ğ¸Ğ»Ğ¸ Ğ² ÑÑ‚Ğ¾Ğ¼ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğµ

| ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ | ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ² Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğµ |
|-----------|---------------------|
| async/await | Ğ’ÑĞµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¾Ğ² Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ |
| tokio::spawn | ĞŸĞ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡ |
| tokio::select! | ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹ |
| broadcast channel | Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹ Ñ†ĞµĞ½ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ°Ğ¼ |
| WebSocket | ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ¾Ñ‚ Binance |
| HTTP ĞºĞ»Ğ¸ĞµĞ½Ñ‚ | Polling Coinbase API Ñ reqwest |
| Graceful shutdown | ĞšĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ²ÑĞµÑ… Ğ·Ğ°Ğ´Ğ°Ñ‡ Ğ¿Ğ¾ Ctrl+C |
| Ğ ĞµĞºĞ¾Ğ½Ğ½ĞµĞºÑ‚ | ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ |
| Ğ¢Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ñ‹ | ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ñ HTTP Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² |
| Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ | tracing Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸ |

## ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ

1. **Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ±Ğ¸Ñ€Ğ¶Ğ¸**: Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹ ĞºĞ»Ğ¸ĞµĞ½Ñ‚ Ğ´Ğ»Ñ ĞµÑ‰Ñ‘ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ±Ğ¸Ñ€Ğ¶Ğ¸ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Kraken). Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ Ğ¸Ñ… Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ API Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ½.

2. **Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸**: Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ²ÑĞµÑ… Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹ Ñ†ĞµĞ½ Ğ² Ñ„Ğ°Ğ¹Ğ» CSV Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ `tokio::fs` Ğ´Ğ»Ñ Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸.

3. **Web Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ**: Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾Ğ¹ HTTP ÑĞµÑ€Ğ²ĞµÑ€ Ñ axum Ğ¸Ğ»Ğ¸ actix-web, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Ñ‡ĞµÑ€ĞµĞ· REST API.

4. **Telegram Ğ±Ğ¾Ñ‚**: Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ¸Ñ€ÑƒĞ¹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ Ğ¾Ğ¿Ğ¾Ğ²ĞµÑ‰ĞµĞ½Ğ¸Ğ¹ Ğ² Telegram, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ teloxide Ğ¸Ğ»Ğ¸ Ğ´Ñ€ÑƒĞ³ÑƒÑ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºÑƒ.

## Ğ”Ğ¾Ğ¼Ğ°ÑˆĞ½ĞµĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ

1. **ĞŸĞ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ°Ñ€Ğ±Ğ¸Ñ‚Ñ€Ğ°Ğ¶-ÑĞºĞ°Ğ½ĞµÑ€**:
   - ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸ÑÑŒ Ğº 3+ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ Ğ±Ğ¸Ñ€Ğ¶Ğ°Ğ¼
   - ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ¹ Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ñƒ Ñ†ĞµĞ½ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
   - Ğ£Ñ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ğ¹ ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ğ¸ Ğ¿Ñ€Ğ¸ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ñ‚Ğ°Ğ±ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
   - Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞ¹ Ğ²ÑĞµ Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸

2. **ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ñ Ğ¿ĞµÑ€ÑĞ¸ÑÑ‚ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚ÑŒÑ**:
   - Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞ¹ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ² SQLite (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ sqlx)
   - Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°Ğ¹ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑĞºĞµ
   - Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ¸ Ñ‡ĞµÑ€ĞµĞ· API

3. **ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸**:
   - Ğ˜Ğ·Ğ¼ĞµÑ€ÑŒ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºÑƒ Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ¾ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
   - ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ²
   - Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸

## Ğ˜Ñ‚Ğ¾Ğ³ Ğ¼ĞµÑÑÑ†Ğ°

ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑÑ! Ğ¢Ñ‹ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ğ» ĞœĞµÑÑÑ† 7: Async Ğ¸ ÑĞµÑ‚Ğ¸. Ğ—Ğ° ÑÑ‚Ğ¾Ñ‚ Ğ¼ĞµÑÑÑ† Ñ‚Ñ‹ Ğ¸Ğ·ÑƒÑ‡Ğ¸Ğ»:

- Ğ Ğ°Ğ·Ğ½Ğ¸Ñ†Ñƒ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğ¼ Ğ¸ Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğ¼ ĞºĞ¾Ğ´Ğ¾Ğ¼
- Ğ Ğ°Ğ±Ğ¾Ñ‚Ñƒ Ñ async/await Ğ¸ Future
- Tokio runtime Ğ¸ ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸
- ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ¸ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
- HTTP Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ñ reqwest
- WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ñ tokio-tungstenite
- Graceful shutdown Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
- Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ real-time Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ

Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ñ‚Ñ‹ Ğ³Ğ¾Ñ‚Ğ¾Ğ² ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ²Ñ‹ÑĞ¾ĞºĞ¾Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑĞµÑ‚ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ‚Ñ€ĞµĞ¹Ğ´Ğ¸Ğ½Ğ³Ğ°!

## ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ñ

[â† ĞŸÑ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğ¹ Ğ´ĞµĞ½ÑŒ](../211-debugging-async-code/ru.md) | [Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ´ĞµĞ½ÑŒ â†’](../213-why-databases-persistence/ru.md)
