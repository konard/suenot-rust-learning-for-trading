# Day 232: Diesel: Models and Schemas

## Trading Analogy

Imagine you're managing a trading terminal. Every order, every trade, every balance change — all of this needs to be stored somewhere. In real-world trading, data is stored in databases: order history, user portfolios, instrument quotes.

**Database schema** is like the structure of an order book: it defines what fields each order has (price, quantity, direction, time). **Model** is a Rust struct that represents a single record from a table, like one specific order in the order book.

Diesel is an ORM (Object-Relational Mapping) for Rust that allows you to:
- Describe database structure in Rust
- Safely execute SQL queries with compile-time checking
- Work with data as regular Rust structs

## What is Diesel?

Diesel is a fast and safe ORM for Rust. Its main advantages:

1. **Compile-time query checking** — SQL errors are caught before running the program
2. **Zero-cost abstractions** — performance comparable to hand-written SQL
3. **Type safety** — impossible to accidentally mix up data types

## Installation and Setup

Add Diesel to your project:

```toml
# Cargo.toml
[dependencies]
diesel = { version = "2.1", features = ["postgres", "chrono"] }
dotenvy = "0.15"
chrono = { version = "0.4", features = ["serde"] }

[dependencies.diesel_migrations]
version = "2.1"
```

Install the Diesel CLI tool:

```bash
cargo install diesel_cli --no-default-features --features postgres
```

Create a `.env` file with database connection:

```bash
DATABASE_URL=postgres://trader:password@localhost/trading_db
```

Initialize the project:

```bash
diesel setup
diesel migration generate create_orders
```

## Creating Database Schema

### Migration: Creating Orders Table

```sql
-- migrations/2024-01-01-000001_create_orders/up.sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(4) NOT NULL CHECK (side IN ('buy', 'sell')),
    price DECIMAL(20, 8) NOT NULL,
    quantity DECIMAL(20, 8) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_orders_symbol ON orders(symbol);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at);
```

```sql
-- migrations/2024-01-01-000001_create_orders/down.sql
DROP TABLE orders;
```

Apply the migration:

```bash
diesel migration run
```

## Schema Generation

After migration, Diesel automatically generates `src/schema.rs`:

```rust
// src/schema.rs (automatically generated by Diesel)
diesel::table! {
    orders (id) {
        id -> Int4,
        symbol -> Varchar,
        side -> Varchar,
        price -> Numeric,
        quantity -> Numeric,
        status -> Varchar,
        created_at -> Timestamp,
        updated_at -> Timestamp,
    }
}
```

## Creating Models

Models are Rust structs that correspond to table records:

```rust
// src/models.rs
use diesel::prelude::*;
use bigdecimal::BigDecimal;
use chrono::NaiveDateTime;

// Model for reading data from DB
#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = crate::schema::orders)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct Order {
    pub id: i32,
    pub symbol: String,
    pub side: String,
    pub price: BigDecimal,
    pub quantity: BigDecimal,
    pub status: String,
    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime,
}

// Model for creating new records
#[derive(Insertable, Debug)]
#[diesel(table_name = crate::schema::orders)]
pub struct NewOrder<'a> {
    pub symbol: &'a str,
    pub side: &'a str,
    pub price: BigDecimal,
    pub quantity: BigDecimal,
    pub status: &'a str,
}

// Model for updating records
#[derive(AsChangeset, Debug)]
#[diesel(table_name = crate::schema::orders)]
pub struct OrderUpdate {
    pub status: Option<String>,
    pub updated_at: Option<NaiveDateTime>,
}
```

## Model Derive Attributes

| Attribute | Purpose |
|-----------|---------|
| `Queryable` | Allows reading data from DB into struct |
| `Selectable` | Automatic field selection for SELECT |
| `Insertable` | Allows inserting struct into DB |
| `AsChangeset` | Allows updating records |
| `Identifiable` | Specifies primary key for relations |
| `Associations` | Defines relationships between tables |

## Practical Example: Trading System

### Complete Project Structure

```rust
// src/main.rs
mod schema;
mod models;

use diesel::prelude::*;
use diesel::pg::PgConnection;
use dotenvy::dotenv;
use std::env;
use bigdecimal::BigDecimal;
use std::str::FromStr;

use models::{Order, NewOrder, OrderUpdate};
use schema::orders;

pub fn establish_connection() -> PgConnection {
    dotenv().ok();
    let database_url = env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    PgConnection::establish(&database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}

// Create a new order
pub fn create_order(
    conn: &mut PgConnection,
    symbol: &str,
    side: &str,
    price: &str,
    quantity: &str,
) -> Order {
    let new_order = NewOrder {
        symbol,
        side,
        price: BigDecimal::from_str(price).unwrap(),
        quantity: BigDecimal::from_str(quantity).unwrap(),
        status: "pending",
    };

    diesel::insert_into(orders::table)
        .values(&new_order)
        .returning(Order::as_returning())
        .get_result(conn)
        .expect("Error saving new order")
}

// Get all active orders by symbol
pub fn get_active_orders(
    conn: &mut PgConnection,
    trading_symbol: &str,
) -> Vec<Order> {
    orders::table
        .filter(orders::symbol.eq(trading_symbol))
        .filter(orders::status.eq("pending"))
        .order(orders::created_at.desc())
        .load::<Order>(conn)
        .expect("Error loading orders")
}

// Update order status
pub fn update_order_status(
    conn: &mut PgConnection,
    order_id: i32,
    new_status: &str,
) -> Order {
    diesel::update(orders::table.find(order_id))
        .set(OrderUpdate {
            status: Some(new_status.to_string()),
            updated_at: Some(chrono::Utc::now().naive_utc()),
        })
        .returning(Order::as_returning())
        .get_result(conn)
        .expect("Error updating order")
}

// Delete filled orders older than 30 days
pub fn cleanup_old_orders(conn: &mut PgConnection) -> usize {
    use chrono::{Utc, Duration};

    let cutoff = Utc::now().naive_utc() - Duration::days(30);

    diesel::delete(
        orders::table
            .filter(orders::status.eq("filled"))
            .filter(orders::created_at.lt(cutoff))
    )
    .execute(conn)
    .expect("Error deleting old orders")
}

fn main() {
    let conn = &mut establish_connection();

    // Create new orders
    println!("=== Creating Orders ===");

    let buy_order = create_order(
        conn, "BTC/USDT", "buy", "42000.50", "0.5"
    );
    println!("Created buy order: {:?}", buy_order);

    let sell_order = create_order(
        conn, "BTC/USDT", "sell", "43000.00", "0.25"
    );
    println!("Created sell order: {:?}", sell_order);

    // Get active orders
    println!("\n=== Active BTC/USDT Orders ===");
    let active = get_active_orders(conn, "BTC/USDT");
    for order in &active {
        println!(
            "ID: {}, {} {} @ {} - Status: {}",
            order.id, order.side, order.quantity, order.price, order.status
        );
    }

    // Execute order
    println!("\n=== Executing Order ===");
    let filled = update_order_status(conn, buy_order.id, "filled");
    println!("Order executed: {:?}", filled);

    // Statistics
    println!("\n=== Statistics ===");
    let total_orders: i64 = orders::table
        .count()
        .get_result(conn)
        .unwrap();
    println!("Total orders in system: {}", total_orders);
}
```

## Extended Example: Portfolio and Positions

### Adding Positions Table

```sql
-- migrations/2024-01-02-000001_create_positions/up.sql
CREATE TABLE positions (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL UNIQUE,
    quantity DECIMAL(20, 8) NOT NULL DEFAULT 0,
    avg_price DECIMAL(20, 8) NOT NULL DEFAULT 0,
    unrealized_pnl DECIMAL(20, 8) NOT NULL DEFAULT 0,
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(4) NOT NULL,
    price DECIMAL(20, 8) NOT NULL,
    quantity DECIMAL(20, 8) NOT NULL,
    commission DECIMAL(20, 8) NOT NULL DEFAULT 0,
    executed_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

### Models with Relationships

```rust
// src/models.rs (extended version)
use diesel::prelude::*;
use bigdecimal::BigDecimal;
use chrono::NaiveDateTime;
use crate::schema::{orders, positions, trades};

#[derive(Queryable, Selectable, Identifiable, Debug, Clone)]
#[diesel(table_name = orders)]
pub struct Order {
    pub id: i32,
    pub symbol: String,
    pub side: String,
    pub price: BigDecimal,
    pub quantity: BigDecimal,
    pub status: String,
    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = positions)]
pub struct Position {
    pub id: i32,
    pub symbol: String,
    pub quantity: BigDecimal,
    pub avg_price: BigDecimal,
    pub unrealized_pnl: BigDecimal,
    pub updated_at: NaiveDateTime,
}

#[derive(Insertable, AsChangeset, Debug)]
#[diesel(table_name = positions)]
pub struct PositionUpdate {
    pub symbol: String,
    pub quantity: BigDecimal,
    pub avg_price: BigDecimal,
    pub unrealized_pnl: BigDecimal,
    pub updated_at: NaiveDateTime,
}

// Trade is associated with an Order
#[derive(Queryable, Selectable, Associations, Debug, Clone)]
#[diesel(belongs_to(Order))]
#[diesel(table_name = trades)]
pub struct Trade {
    pub id: i32,
    pub order_id: Option<i32>,
    pub symbol: String,
    pub side: String,
    pub price: BigDecimal,
    pub quantity: BigDecimal,
    pub commission: BigDecimal,
    pub executed_at: NaiveDateTime,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = trades)]
pub struct NewTrade {
    pub order_id: Option<i32>,
    pub symbol: String,
    pub side: String,
    pub price: BigDecimal,
    pub quantity: BigDecimal,
    pub commission: BigDecimal,
}
```

### Complex Queries

```rust
use diesel::prelude::*;
use diesel::dsl::sum;
use bigdecimal::BigDecimal;

// Get trades for an order using associations
pub fn get_trades_for_order(
    conn: &mut PgConnection,
    order: &Order,
) -> Vec<Trade> {
    Trade::belonging_to(order)
        .select(Trade::as_select())
        .load(conn)
        .expect("Error loading trades")
}

// Aggregation: total trading volume by symbol
pub fn get_total_volume(
    conn: &mut PgConnection,
    trading_symbol: &str,
) -> Option<BigDecimal> {
    use crate::schema::trades::dsl::*;

    trades
        .filter(symbol.eq(trading_symbol))
        .select(sum(quantity))
        .first::<Option<BigDecimal>>(conn)
        .expect("Error calculating volume")
}

// Transaction: execute order with trade creation
pub fn execute_order(
    conn: &mut PgConnection,
    order_id: i32,
    exec_price: BigDecimal,
    exec_quantity: BigDecimal,
    commission_rate: BigDecimal,
) -> Result<Trade, diesel::result::Error> {
    conn.transaction(|conn| {
        // Get the order
        let order = orders::table
            .find(order_id)
            .first::<Order>(conn)?;

        // Create trade
        let commission = &exec_price * &exec_quantity * &commission_rate;
        let new_trade = NewTrade {
            order_id: Some(order_id),
            symbol: order.symbol.clone(),
            side: order.side.clone(),
            price: exec_price,
            quantity: exec_quantity.clone(),
            commission,
        };

        let trade = diesel::insert_into(trades::table)
            .values(&new_trade)
            .returning(Trade::as_returning())
            .get_result(conn)?;

        // Update order status
        diesel::update(orders::table.find(order_id))
            .set(orders::status.eq("filled"))
            .execute(conn)?;

        // Update position
        update_position(conn, &order.symbol, &order.side, &exec_quantity)?;

        Ok(trade)
    })
}

fn update_position(
    conn: &mut PgConnection,
    symbol: &str,
    side: &str,
    quantity: &BigDecimal,
) -> Result<(), diesel::result::Error> {
    use crate::schema::positions::dsl;

    let existing = dsl::positions
        .filter(dsl::symbol.eq(symbol))
        .first::<Position>(conn)
        .optional()?;

    match existing {
        Some(pos) => {
            let new_qty = if side == "buy" {
                &pos.quantity + quantity
            } else {
                &pos.quantity - quantity
            };

            diesel::update(dsl::positions.find(pos.id))
                .set(dsl::quantity.eq(new_qty))
                .execute(conn)?;
        }
        None => {
            let new_pos = PositionUpdate {
                symbol: symbol.to_string(),
                quantity: quantity.clone(),
                avg_price: BigDecimal::from(0),
                unrealized_pnl: BigDecimal::from(0),
                updated_at: chrono::Utc::now().naive_utc(),
            };

            diesel::insert_into(dsl::positions)
                .values(&new_pos)
                .execute(conn)?;
        }
    }

    Ok(())
}
```

## What We Learned

| Concept | Description |
|---------|-------------|
| Schema | Rust description of database table structure |
| Model | Rust struct corresponding to a table record |
| `Queryable` | Reading data from DB |
| `Insertable` | Inserting data into DB |
| `AsChangeset` | Updating data in DB |
| `Associations` | Relationships between tables |
| Migrations | Versioning database changes |
| Transactions | Atomic operations across multiple tables |

## Exercises

1. **Quotes Table**: Create a migration and models for a `quotes` table with fields: `symbol`, `bid_price`, `ask_price`, `bid_size`, `ask_size`, `timestamp`. Implement functions to write and read the latest quotes.

2. **Balance History**: Create a `balance_history` table to track user balance changes. Add a function that records balance changes on each trade.

3. **Pagination**: Implement a function `get_orders_paginated(page: i64, per_page: i64)` that returns orders with pagination and total page count.

4. **Symbol Statistics**: Write a function that returns aggregated statistics for each symbol: order count, total volume, average price.

## Homework

1. **Complete Trading System**: Create a module with tables `users`, `wallets`, `orders`, `trades`, `positions`. Implement:
   - User registration
   - Wallet deposit
   - Order placement with balance checking
   - Order execution with position update

2. **Risk Management**: Add a `risk_limits` table with limits for maximum position and daily loss. Implement limit checking before order placement.

3. **Audit**: Create an `audit_log` table for logging all changes to critical tables. Use Diesel to record events on each operation.

4. **Query Optimization**: Analyze the created queries and add necessary indexes. Implement caching for frequently requested data (latest quotes, active positions).

## Navigation

[← Previous day](../231-diesel-connection-setup/en.md) | [Next day →](../233-diesel-crud-operations/en.md)
