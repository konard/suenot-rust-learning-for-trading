# –î–µ–Ω—å 308: –ú–∏–∫—Ä–æ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: –∞–ª–ª–æ–∫–∞—Ü–∏–∏

## –ê–Ω–∞–ª–æ–≥–∏—è –∏–∑ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞

–ü—Ä–µ–¥—Å—Ç–∞–≤—å —Ç—Ä–µ–π–¥–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç –¥–µ–Ω—å–≥–∏ –º–µ–∂–¥—É —Ä–∞–∑–Ω—ã–º–∏ –±–∏—Ä–∂–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–π —Å–¥–µ–ª–∫–∏. –î–∞–∂–µ –µ—Å–ª–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –ø—Ä–∏–±—ã–ª—å–Ω–∞—è, –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –Ω–∞ –ø–µ—Ä–µ–≤–æ–¥—ã —Å—ä–µ–¥–∞—é—Ç –≤—Å—é –ø—Ä–∏–±—ã–ª—å. –ö–æ–º–∏—Å—Å–∏—è 0.1% –∑–∞ –ø–µ—Ä–µ–≤–æ–¥ –∫–∞–∂–µ—Ç—Å—è –º–µ–ª–æ—á—å—é, –Ω–æ –ø—Ä–∏ 10,000 –æ–ø–µ—Ä–∞—Ü–∏–π –≤ –¥–µ–Ω—å —ç—Ç–æ —É–∂–µ —Å–µ—Ä—å—ë–∑–Ω—ã–µ –ø–æ—Ç–µ—Ä–∏.

–í –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ **–∞–ª–ª–æ–∫–∞—Ü–∏—è –ø–∞–º—è—Ç–∏** ‚Äî —ç—Ç–æ –∫–∞–∫ –ø–µ—Ä–µ–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤ –º–µ–∂–¥—É —Å—á–µ—Ç–∞–º–∏. –ö–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –º—ã —Å–æ–∑–¥–∞—ë–º `Vec`, `String`, `Box` –∏–ª–∏ `HashMap`, Rust –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –∫ —Å–∏—Å—Ç–µ–º–Ω–æ–º—É –∞–ª–ª–æ–∫–∞—Ç–æ—Ä—É, —á—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –≤—Ä–µ–º—è. –î–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –ø—Ä–æ–≥—Ä–∞–º–º —ç—Ç–æ –Ω–µ–∑–∞–º–µ—Ç–Ω–æ, –Ω–æ –≤ –≤—ã—Å–æ–∫–æ—á–∞—Å—Ç–æ—Ç–Ω–æ–º —Ç—Ä–µ–π–¥–∏–Ω–≥–µ (HFT), –≥–¥–µ —Å—á—ë—Ç –∏–¥—ë—Ç –Ω–∞ –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥—ã, –ª–∏—à–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –º–æ–≥—É—Ç —Å—Ç–æ–∏—Ç—å –¥–µ–Ω–µ–≥.

## –ü–æ—á–µ–º—É –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –≤–∞–∂–Ω—ã –≤ –∞–ª–≥–æ—Ç—Ä–µ–π–¥–∏–Ω–≥–µ?

–í —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö –∫—Ä–∏—Ç–∏—á–Ω–∞ **latency** (–∑–∞–¥–µ—Ä–∂–∫–∞) ‚Äî –≤—Ä–µ–º—è –º–µ–∂–¥—É –ø–æ–ª—É—á–µ–Ω–∏–µ–º —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –æ—Ä–¥–µ—Ä–∞. –î–∞–∂–µ –∑–∞–¥–µ—Ä–∂–∫–∞ –≤ 100 –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥ –º–æ–∂–µ—Ç –æ–∑–Ω–∞—á–∞—Ç—å –ø—Ä–æ–∏–≥—Ä—ã—à –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–∞–º.

| –û–ø–µ—Ä–∞—Ü–∏—è | –¢–∏–ø–∏—á–Ω–æ–µ –≤—Ä–µ–º—è | –í–ª–∏—è–Ω–∏–µ |
|----------|---------------|---------|
| –ê–ª–ª–æ–∫–∞—Ü–∏—è heap (malloc) | ~100-500 –Ω—Å | –ó–∞–º–µ–¥–ª—è–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É |
| –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö | ~10-50 –Ω—Å/KB | –†–∞—Å—Ç—ë—Ç —Å —Ä–∞–∑–º–µ—Ä–æ–º |
| Stack –æ–ø–µ—Ä–∞—Ü–∏–∏ | ~1-5 –Ω—Å | –ü–æ—á—Ç–∏ –Ω–µ–∑–∞–º–µ—Ç–Ω–æ |
| –°–∏—Å—Ç–µ–º–Ω—ã–π –≤—ã–∑–æ–≤ | ~1-10 –º–∫—Å | –û—á–µ–Ω—å –¥–æ—Ä–æ–≥–æ |

**–ü—Ä–æ–±–ª–µ–º—ã —á—Ä–µ–∑–º–µ—Ä–Ω—ã—Ö –∞–ª–ª–æ–∫–∞—Ü–∏–π:**
1. **Latency —Å–ø–∞–π–∫–∏** ‚Äî –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏
2. **CPU cache misses** ‚Äî –¥–∞–Ω–Ω—ã–µ —Ä–∞–∑–±—Ä–æ—Å–∞–Ω—ã –ø–æ –ø–∞–º—è—Ç–∏
3. **–§—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏—è –ø–∞–º—è—Ç–∏** ‚Äî –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
4. **Garbage collection –ø–∞—É–∑—ã** (–Ω–µ –≤ Rust, –Ω–æ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞)

## –ì–¥–µ –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –≤ Rust?

```rust
// ‚ùå –ê–ª–ª–æ–∫–∞—Ü–∏–∏ heap
let prices = Vec::new();           // –ê–ª–ª–æ–∫–∞—Ü–∏—è –ø—Ä–∏ push
let symbol = String::from("BTCUSDT"); // –ê–ª–ª–æ–∫–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏
let data = Box::new(MarketData {});   // –ê–ª–ª–æ–∫–∞—Ü–∏—è –Ω–∞ heap
let map = HashMap::new();           // –ê–ª–ª–æ–∫–∞—Ü–∏—è + internal buffers

// ‚úÖ –î–∞–Ω–Ω—ã–µ –Ω–∞ stack (–±—ã—Å—Ç—Ä–æ)
let price = 42000.0;
let array = [0.0; 100];  // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä
let tuple = (price, quantity);
```

## –ü—Ä–∏–º–µ—Ä: –ò–∑–º–µ—Ä–µ–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

/// –ê–ª–ª–æ–∫–∞—Ç–æ—Ä-–æ–±—ë—Ä—Ç–∫–∞ –¥–ª—è –ø–æ–¥—Å—á—ë—Ç–∞ –∞–ª–ª–æ–∫–∞—Ü–∏–π
struct CountingAllocator;

static ALLOCATED: AtomicUsize = AtomicUsize::new(0);
static DEALLOCATED: AtomicUsize = AtomicUsize::new(0);
static ALLOCATION_COUNT: AtomicUsize = AtomicUsize::new(0);

unsafe impl GlobalAlloc for CountingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        ALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
        ALLOCATION_COUNT.fetch_add(1, Ordering::SeqCst);
        System.alloc(layout)
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        DEALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
        System.dealloc(ptr, layout);
    }
}

#[global_allocator]
static GLOBAL: CountingAllocator = CountingAllocator;

fn get_allocation_stats() -> (usize, usize, usize) {
    let allocated = ALLOCATED.load(Ordering::SeqCst);
    let deallocated = DEALLOCATED.load(Ordering::SeqCst);
    let count = ALLOCATION_COUNT.load(Ordering::SeqCst);
    (allocated, deallocated, count)
}

fn reset_allocation_stats() {
    ALLOCATED.store(0, Ordering::SeqCst);
    DEALLOCATED.store(0, Ordering::SeqCst);
    ALLOCATION_COUNT.store(0, Ordering::SeqCst);
}

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã –∏ –æ–±—ä—ë–º–∞
#[derive(Debug, Clone)]
struct PriceLevel {
    price: f64,
    quantity: f64,
}

// ‚ùå –ù–µ–æ–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è: –º–Ω–æ–≥–æ –∞–ª–ª–æ–∫–∞—Ü–∏–π
fn process_orderbook_slow(levels: &[(f64, f64)]) -> Vec<PriceLevel> {
    let mut result = Vec::new(); // –ê–ª–ª–æ–∫–∞—Ü–∏—è 1

    for &(price, qty) in levels {
        let level = PriceLevel { // –ö–∞–∂–¥–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è ‚Äî –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
            price,
            quantity: qty,
        };
        result.push(level); // –ú–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏—é
    }

    result
}

// ‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è: –æ–¥–Ω–∞ –∞–ª–ª–æ–∫–∞—Ü–∏—è
fn process_orderbook_fast(levels: &[(f64, f64)]) -> Vec<PriceLevel> {
    let mut result = Vec::with_capacity(levels.len()); // –¢–æ—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä

    for &(price, qty) in levels {
        result.push(PriceLevel { price, quantity: qty });
    }

    result
}

fn main() {
    let levels = vec![
        (42000.0, 1.5),
        (42001.0, 2.3),
        (42002.0, 0.8),
        (42003.0, 1.2),
        (42004.0, 3.1),
    ];

    println!("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π ===\n");

    // –¢–µ—Å—Ç –Ω–µ–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    reset_allocation_stats();
    let _ = process_orderbook_slow(&levels);
    let (alloc1, dealloc1, count1) = get_allocation_stats();
    println!("‚ùå –ú–µ–¥–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è (–±–µ–∑ with_capacity):");
    println!("   –ê–ª–ª–æ—Ü–∏—Ä–æ–≤–∞–Ω–æ: {} –±–∞–π—Ç", alloc1);
    println!("   –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–ª–ª–æ–∫–∞—Ü–∏–π: {}", count1);

    // –¢–µ—Å—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    reset_allocation_stats();
    let _ = process_orderbook_fast(&levels);
    let (alloc2, dealloc2, count2) = get_allocation_stats();
    println!("\n‚úÖ –ë—ã—Å—Ç—Ä–∞—è –≤–µ—Ä—Å–∏—è (—Å with_capacity):");
    println!("   –ê–ª–ª–æ—Ü–∏—Ä–æ–≤–∞–Ω–æ: {} –±–∞–π—Ç", alloc2);
    println!("   –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–ª–ª–æ–∫–∞—Ü–∏–π: {}", count2);

    println!("\nüìä –†–∞–∑–Ω–∏—Ü–∞:");
    println!("   –≠–∫–æ–Ω–æ–º–∏—è –∞–ª–ª–æ–∫–∞—Ü–∏–π: {} —Ä–∞–∑", count1 as f64 / count2 as f64);
}
```

## –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 1: –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏

```rust
use std::collections::HashMap;

#[derive(Debug)]
struct Trade {
    symbol: String,
    price: f64,
    quantity: f64,
}

// ‚ùå –ü–ª–æ—Ö–æ: —Ä–∞—Å—Ç—É—â–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–∏
fn collect_trades_bad(count: usize) -> Vec<Trade> {
    let mut trades = Vec::new(); // Capacity = 0

    for i in 0..count {
        trades.push(Trade {  // –†–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è –ø—Ä–∏ 1, 2, 4, 8, 16...
            symbol: format!("BTC-{}", i),
            price: 42000.0 + i as f64,
            quantity: 0.1,
        });
    }

    trades
}

// ‚úÖ –•–æ—Ä–æ—à–æ: –æ–¥–Ω–∞ –∞–ª–ª–æ–∫–∞—Ü–∏—è
fn collect_trades_good(count: usize) -> Vec<Trade> {
    let mut trades = Vec::with_capacity(count); // –¢–æ—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä

    for i in 0..count {
        trades.push(Trade {
            symbol: format!("BTC-{}", i),
            price: 42000.0 + i as f64,
            quantity: 0.1,
        });
    }

    trades
}

// ‚úÖ –ï—â—ë –ª—É—á—à–µ: –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∞
fn collect_trades_reuse(count: usize, buffer: &mut Vec<Trade>) {
    buffer.clear(); // –ù–µ –¥–µ–∞–ª–ª–æ—Ü–∏—Ä—É–µ—Ç –ø–∞–º—è—Ç—å
    buffer.reserve(count); // –†–∞—Å—à–∏—Ä—è–µ—Ç capacity –µ—Å–ª–∏ –Ω—É–∂–Ω–æ

    for i in 0..count {
        buffer.push(Trade {
            symbol: format!("BTC-{}", i),
            price: 42000.0 + i as f64,
            quantity: 0.1,
        });
    }
}

fn main() {
    println!("=== –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è ===\n");

    let count = 1000;

    // –í–µ—Ä—Å–∏—è —Å —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è–º–∏
    reset_allocation_stats();
    let start = std::time::Instant::now();
    let trades1 = collect_trades_bad(count);
    let time1 = start.elapsed();
    let (alloc1, _, count1) = get_allocation_stats();
    println!("‚ùå –ë–µ–∑ capacity:");
    println!("   –í—Ä–µ–º—è: {:?}", time1);
    println!("   –ê–ª–ª–æ–∫–∞—Ü–∏–π: {}", count1);

    // –í–µ—Ä—Å–∏—è —Å with_capacity
    reset_allocation_stats();
    let start = std::time::Instant::now();
    let trades2 = collect_trades_good(count);
    let time2 = start.elapsed();
    let (alloc2, _, count2) = get_allocation_stats();
    println!("\n‚úÖ –° with_capacity:");
    println!("   –í—Ä–µ–º—è: {:?}", time2);
    println!("   –ê–ª–ª–æ–∫–∞—Ü–∏–π: {}", count2);

    // –í–µ—Ä—Å–∏—è —Å –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
    let mut buffer = Vec::new();
    reset_allocation_stats();
    let start = std::time::Instant::now();
    collect_trades_reuse(count, &mut buffer);
    let time3 = start.elapsed();
    let (alloc3, _, count3) = get_allocation_stats();
    println!("\n‚úÖ –° –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –±—É—Ñ–µ—Ä–∞:");
    println!("   –í—Ä–µ–º—è: {:?}", time3);
    println!("   –ê–ª–ª–æ–∫–∞—Ü–∏–π: {}", count3);

    println!("\nüìä –£—Å–∫–æ—Ä–µ–Ω–∏–µ: {:.2}x", time1.as_nanos() as f64 / time3.as_nanos() as f64);
}
```

## –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 2: –ò–∑–±–µ–≥–∞–µ–º –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫

```rust
use std::borrow::Cow;

#[derive(Debug)]
struct Order<'a> {
    symbol: Cow<'a, str>,  // Copy-on-write: –∑–∞–∏–º—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –≤–ª–∞–¥–µ–µ—Ç
    price: f64,
    quantity: f64,
}

// ‚ùå –ü–ª–æ—Ö–æ: –∫–ª–æ–Ω–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É –∫–∞–∂–¥—ã–π —Ä–∞–∑
fn create_order_bad(symbol: &str, price: f64, qty: f64) -> Order<'static> {
    Order {
        symbol: Cow::Owned(symbol.to_string()), // –ê–ª–ª–æ–∫–∞—Ü–∏—è
        price,
        quantity: qty,
    }
}

// ‚úÖ –•–æ—Ä–æ—à–æ: –∑–∞–∏–º—Å—Ç–≤—É–µ—Ç —Å—Ç—Ä–æ–∫—É
fn create_order_good(symbol: &str, price: f64, qty: f64) -> Order {
    Order {
        symbol: Cow::Borrowed(symbol), // –ë–µ–∑ –∞–ª–ª–æ–∫–∞—Ü–∏–∏
        price,
        quantity: qty,
    }
}

// ‚úÖ –£–º–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ: –∫–ª–æ–Ω–∏—Ä—É–µ—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏
fn normalize_symbol(symbol: &str) -> Cow<str> {
    if symbol.contains('-') {
        // –ù—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å ‚Äî –∫–ª–æ–Ω–∏—Ä—É–µ–º
        Cow::Owned(symbol.replace('-', ""))
    } else {
        // –ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ‚Äî –∑–∞–∏–º—Å—Ç–≤—É–µ–º
        Cow::Borrowed(symbol)
    }
}

fn main() {
    println!("=== –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–æ–∫ —Å Cow ===\n");

    let symbol = "BTCUSDT";

    // –ü–ª–æ—Ö–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
    reset_allocation_stats();
    let order1 = create_order_bad(symbol, 42000.0, 1.0);
    let (alloc1, _, count1) = get_allocation_stats();
    println!("‚ùå –° –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º: {} –∞–ª–ª–æ–∫–∞—Ü–∏–π, {} –±–∞–π—Ç", count1, alloc1);

    // –•–æ—Ä–æ—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç
    reset_allocation_stats();
    let order2 = create_order_good(symbol, 42000.0, 1.0);
    let (alloc2, _, count2) = get_allocation_stats();
    println!("‚úÖ –° –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ–º: {} –∞–ª–ª–æ–∫–∞—Ü–∏–π, {} –±–∞–π—Ç", count2, alloc2);

    println!("\n=== –£–º–Ω–æ–µ –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ ===");

    reset_allocation_stats();
    let normalized1 = normalize_symbol("BTCUSDT");
    let (a1, _, c1) = get_allocation_stats();
    println!("–ë–µ–∑ '-': {} –∞–ª–ª–æ–∫–∞—Ü–∏–π (–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ)", c1);

    reset_allocation_stats();
    let normalized2 = normalize_symbol("BTC-USDT");
    let (a2, _, c2) = get_allocation_stats();
    println!("–° '-': {} –∞–ª–ª–æ–∫–∞—Ü–∏–π (–∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è)", c2);
}
```

## –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 3: –ü—É–ª—ã –æ–±—ä–µ–∫—Ç–æ–≤

```rust
use std::collections::VecDeque;

/// –ü—É–ª –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±—É—Ñ–µ—Ä–æ–≤
struct BufferPool {
    pool: VecDeque<Vec<f64>>,
    capacity: usize,
}

impl BufferPool {
    fn new(capacity: usize) -> Self {
        BufferPool {
            pool: VecDeque::new(),
            capacity,
        }
    }

    /// –ë–µ—Ä—ë–º –±—É—Ñ–µ—Ä –∏–∑ –ø—É–ª–∞ –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π
    fn acquire(&mut self) -> Vec<f64> {
        self.pool.pop_front().unwrap_or_else(|| Vec::with_capacity(self.capacity))
    }

    /// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±—É—Ñ–µ—Ä –≤ –ø—É–ª
    fn release(&mut self, mut buffer: Vec<f64>) {
        buffer.clear(); // –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ, –Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º capacity
        if self.pool.len() < 10 { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø—É–ª–∞
            self.pool.push_back(buffer);
        }
        // –ò–Ω–∞—á–µ –±—É—Ñ–µ—Ä –±—É–¥–µ—Ç –¥—Ä–æ–ø–Ω—É—Ç
    }
}

/// –†–∞—Å—á—ë—Ç —Å–∫–æ–ª—å–∑—è—â–µ–π —Å—Ä–µ–¥–Ω–µ–π
fn calculate_sma(prices: &[f64], period: usize, buffer: &mut Vec<f64>) -> f64 {
    buffer.clear();
    buffer.extend_from_slice(&prices[prices.len() - period..]);
    buffer.iter().sum::<f64>() / period as f64
}

fn main() {
    let prices: Vec<f64> = (0..1000).map(|i| 42000.0 + i as f64 * 0.5).collect();
    let iterations = 10000;

    println!("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –ø—É–ª–æ–º –∏ –±–µ–∑ –ø—É–ª–∞ ===\n");

    // ‚ùå –ë–µ–∑ –ø—É–ª–∞: –∫–∞–∂–¥—ã–π —Ä–∞–∑ –Ω–æ–≤–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
    reset_allocation_stats();
    let start = std::time::Instant::now();
    for _ in 0..iterations {
        let mut buffer = Vec::new();
        let _sma = calculate_sma(&prices, 20, &mut buffer);
    }
    let time1 = start.elapsed();
    let (alloc1, _, count1) = get_allocation_stats();
    println!("‚ùå –ë–µ–∑ –ø—É–ª–∞:");
    println!("   –í—Ä–µ–º—è: {:?}", time1);
    println!("   –ê–ª–ª–æ–∫–∞—Ü–∏–π: {}", count1);

    // ‚úÖ –° –ø—É–ª–æ–º: –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º –±—É—Ñ–µ—Ä—ã
    reset_allocation_stats();
    let start = std::time::Instant::now();
    let mut pool = BufferPool::new(100);
    for _ in 0..iterations {
        let mut buffer = pool.acquire();
        let _sma = calculate_sma(&prices, 20, &mut buffer);
        pool.release(buffer);
    }
    let time2 = start.elapsed();
    let (alloc2, _, count2) = get_allocation_stats();
    println!("\n‚úÖ –° –ø—É–ª–æ–º:");
    println!("   –í—Ä–µ–º—è: {:?}", time2);
    println!("   –ê–ª–ª–æ–∫–∞—Ü–∏–π: {}", count2);

    println!("\nüìä –£—Å–∫–æ—Ä–µ–Ω–∏–µ: {:.2}x", time1.as_nanos() as f64 / time2.as_nanos() as f64);
    println!("üìä –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π: {:.1}%", (1.0 - count2 as f64 / count1 as f64) * 100.0);
}
```

## –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 4: SmallVec ‚Äî –≥–∏–±—Ä–∏–¥–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ

```rust
// –¢—Ä–µ–±—É–µ—Ç: cargo add smallvec
use smallvec::{SmallVec, smallvec};

/// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–±–æ–ª—å—à–∏—Ö —Å–ø–∏—Å–∫–æ–≤ –æ—Ä–¥–µ—Ä–æ–≤
#[derive(Debug)]
struct OrderUpdate {
    // –î–æ 4 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞ stack, –±–æ–ª—å—à–µ ‚Äî –Ω–∞ heap
    price_levels: SmallVec<[(f64, f64); 4]>,
}

impl OrderUpdate {
    fn new() -> Self {
        OrderUpdate {
            price_levels: smallvec![],
        }
    }

    fn add_level(&mut self, price: f64, qty: f64) {
        self.price_levels.push((price, qty));
    }

    fn total_volume(&self) -> f64 {
        self.price_levels.iter().map(|(_, qty)| qty).sum()
    }
}

fn main() {
    println!("=== SmallVec: stack –¥–ª—è –º–∞–ª—ã—Ö –¥–∞–Ω–Ω—ã—Ö ===\n");

    // –ú–∞–ª—ã–π –æ–±—ä—ë–º ‚Äî –æ—Å—Ç–∞—ë—Ç—Å—è –Ω–∞ stack
    reset_allocation_stats();
    let mut update1 = OrderUpdate::new();
    update1.add_level(42000.0, 1.0);
    update1.add_level(42001.0, 2.0);
    let (alloc1, _, count1) = get_allocation_stats();
    println!("‚úÖ 2 —ç–ª–µ–º–µ–Ω—Ç–∞ (stack):");
    println!("   –ê–ª–ª–æ–∫–∞—Ü–∏–π: {}", count1);
    println!("   –û–±—ä—ë–º: {}", update1.total_volume());

    // –ë–æ–ª—å—à–µ 4 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ‚Äî –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –Ω–∞ heap
    reset_allocation_stats();
    let mut update2 = OrderUpdate::new();
    for i in 0..10 {
        update2.add_level(42000.0 + i as f64, 1.0);
    }
    let (alloc2, _, count2) = get_allocation_stats();
    println!("\n‚úÖ 10 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (heap –ø–æ—Å–ª–µ 4-–≥–æ):");
    println!("   –ê–ª–ª–æ–∫–∞—Ü–∏–π: {}", count2);
    println!("   –û–±—ä—ë–º: {}", update2.total_volume());

    println!("\nüìù SmallVec –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç—Å—è –º–µ–∂–¥—É stack –∏ heap");
}
```

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

### –ö–æ–≥–¥–∞ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∞–ª–ª–æ–∫–∞—Ü–∏–∏?

1. **–ò–∑–º–µ—Ä—å —Å–Ω–∞—á–∞–ª–∞** ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π –ø—Ä–æ—Ñ–∞–π–ª–µ—Ä—ã (perf, valgrind, heaptrack)
2. **–ì–æ—Ä—è—á–∏–µ –ø—É—Ç–∏** ‚Äî –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–π –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç—ã—Å—è—á–∏ —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
3. **Latency-critical** ‚Äî HFT, real-time –æ–±—Ä–∞–±–æ—Ç–∫–∞ market data
4. **–ù–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–π –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω–æ** ‚Äî —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –≤–∞–∂–Ω–µ–µ –º–∏–∫—Ä–æ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π

### –ß–µ–∫-–ª–∏—Å—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∞–ª–ª–æ–∫–∞—Ü–∏–π

```rust
// ‚úÖ –•–æ—Ä–æ—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏
Vec::with_capacity(n)        // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
HashMap::with_capacity(n)    // –¢–æ –∂–µ –¥–ª—è map
String::with_capacity(n)     // –ò –¥–ª—è —Å—Ç—Ä–æ–∫
buffer.clear()               // –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤–º–µ—Å—Ç–æ –Ω–æ–≤–æ–≥–æ Vec::new()
&str –≤–º–µ—Å—Ç–æ String           // –ó–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –≤–º–µ—Å—Ç–æ –≤–ª–∞–¥–µ–Ω–∏—è
Cow<str>                     // Copy-on-write
SmallVec                     // Stack –¥–ª—è –º–∞–ª—ã—Ö –¥–∞–Ω–Ω—ã—Ö
arrayvec                     // Vec —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –Ω–∞ stack
```

### –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

```bash
# –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π
cargo install cargo-flamegraph
cargo flamegraph --bin my_trading_bot

# –ê–Ω–∞–ª–∏–∑ heap –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
valgrind --tool=massif ./target/release/my_trading_bot
ms_print massif.out.*

# –ü–æ–¥—Å—á—ë—Ç –∞–ª–ª–æ–∫–∞—Ü–∏–π
cargo add dhat
# –î–æ–±–∞–≤–∏—Ç—å #[global_allocator] static ALLOC: dhat::Alloc = dhat::Alloc;
```

## –ß—Ç–æ –º—ã —É–∑–Ω–∞–ª–∏

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –û–ø–∏—Å–∞–Ω–∏–µ |
|-----------|----------|
| **Heap allocation** | –ê–ª–ª–æ–∫–∞—Ü–∏—è –ø–∞–º—è—Ç–∏ —á–µ—Ä–µ–∑ —Å–∏—Å—Ç–µ–º–Ω—ã–π –∞–ª–ª–æ–∫–∞—Ç–æ—Ä (–º–µ–¥–ª–µ–Ω–Ω–æ) |
| **Stack allocation** | –ë—ã—Å—Ç—Ä–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ –Ω–∞ —Å—Ç–µ–∫–µ |
| **with_capacity** | –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è Vec/HashMap/String |
| **Buffer reuse** | –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ .clear() |
| **Cow** | Copy-on-write: –∑–∞–∏–º—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∫–ª–æ–Ω–∏—Ä—É–µ—Ç –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ |
| **Object pool** | –ü—É–ª –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è |
| **SmallVec** | –ì–∏–±—Ä–∏–¥ stack/heap –¥–ª—è –º–∞–ª—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π |
| **Zero-copy** | –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –±–µ–∑ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è |

## –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ

1. **–ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π**: –ù–∞–ø–∏—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è:
   - –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ—Ç–æ–∫ market data (1000 –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π/—Å–µ–∫)
   - –°—á–∏—Ç–∞–µ—Ç —Ç–æ–ø-10 –∞–∫—Ç–∏–≤–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
   - –ó–∞–º–µ—Ä—è–π –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –¥–æ –∏ –ø–æ—Å–ª–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
   - –ò—Å–ø–æ–ª—å–∑—É–π custom allocator –¥–ª—è –ø–æ–¥—Å—á—ë—Ç–∞

2. **Object Pool –¥–ª—è –æ—Ä–¥–µ—Ä–æ–≤**: –†–µ–∞–ª–∏–∑—É–π –ø—É–ª –æ–±—ä–µ–∫—Ç–æ–≤:
   - –ü—É–ª —Å—Ç—Ä—É–∫—Ç—É—Ä `Order` —Å capacity 1000
   - –ú–µ—Ç–æ–¥—ã acquire/release
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø—É–ª–∞ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
   - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (hit rate, miss rate)

3. **Zero-allocation –ø–∞—Ä—Å–µ—Ä**: –°–æ–∑–¥–∞–π –ø–∞—Ä—Å–µ—Ä JSON market data:
   - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç `&str` –≤–º–µ—Å—Ç–æ `String` –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ
   - SmallVec –¥–ª—è –º–∞—Å—Å–∏–≤–æ–≤
   - –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ—Ç –±—É—Ñ–µ—Ä—ã –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏
   - –°—Ä–∞–≤–Ω–∏ —Å –Ω–∞–∏–≤–Ω–æ–π –≤–µ—Ä—Å–∏–µ–π

4. **–ë–µ–Ω—á–º–∞—Ä–∫ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ**: –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:
   - `Vec` vs `SmallVec` vs `ArrayVec`
   - `String` vs `&str` vs `Cow<str>`
   - HashMap —Å –∏ –±–µ–∑ `with_capacity`
   - –ò—Å–ø–æ–ª—å–∑—É–π criterion –¥–ª—è —Ç–æ—á–Ω—ã—Ö –∏–∑–º–µ—Ä–µ–Ω–∏–π

## –ù–∞–≤–∏–≥–∞—Ü–∏—è

[‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å](../294-overfitting-strategy-optimization/ru.md)
