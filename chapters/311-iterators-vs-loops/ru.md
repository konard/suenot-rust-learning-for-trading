# –î–µ–Ω—å 311: –ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã vs —Ü–∏–∫–ª—ã: —á—Ç–æ –±—ã—Å—Ç—Ä–µ–µ

## –ê–Ω–∞–ª–æ–≥–∏—è –∏–∑ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞

–ü—Ä–µ–¥—Å—Ç–∞–≤—å –¥–≤—É—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤, –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é—â–∏—Ö —Ç—ã—Å—è—á–∏ —Å–¥–µ–ª–æ–∫:

**–¢—Ä–µ–π–¥–µ—Ä —Å —Ü–∏–∫–ª–∞–º–∏** (–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥):
- –ë–µ—Ä—ë—Ç Excel —Ñ–∞–π–ª —Å –∏—Å—Ç–æ—Ä–∏–µ–π —Å–¥–µ–ª–æ–∫
- –í—Ä—É—á–Ω—É—é –ø–µ—Ä–µ–±–∏—Ä–∞–µ—Ç –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É
- –î–ª—è –∫–∞–∂–¥–æ–π —Å–¥–µ–ª–∫–∏ –≤—ã—á–∏—Å–ª—è–µ—Ç –ø—Ä–∏–±—ã–ª—å
- –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –Ω–æ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü
- –ó–∞—Ç–µ–º —Å–Ω–æ–≤–∞ –ø–µ—Ä–µ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –ø–æ–¥—Å—á—ë—Ç–∞ —Å—Ä–µ–¥–Ω–µ–π –ø—Ä–∏–±—ã–ª–∏
- –ò –µ—â—ë —Ä–∞–∑ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —É–±—ã—Ç–æ—á–Ω—ã—Ö —Å–¥–µ–ª–æ–∫

**–¢—Ä–µ–π–¥–µ—Ä —Å –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞–º–∏** (—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥):
- –ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–¥–∏–Ω —Ä–∞–∑
- –í—ã—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ü–µ–ø–æ—á–∫—É –æ–ø–µ—Ä–∞—Ü–∏–π: "–≤—ã—á–∏—Å–ª–∏—Ç—å –ø—Ä–∏–±—ã–ª—å ‚Üí –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–±—ã–ª—å–Ω—ã–µ ‚Üí –≤—ã—á–∏—Å–ª–∏—Ç—å —Å—Ä–µ–¥–Ω–µ–µ"
- –ö–æ–º–ø—å—é—Ç–µ—Ä –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –≤—Å—é —Ü–µ–ø–æ—á–∫—É –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –∑–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥
- –ù–∏–∫–∞–∫–∏—Ö –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö –∫–æ–ø–∏–π –¥–∞–Ω–Ω—ã—Ö
- –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –ø—Ä–∏–º–µ–Ω–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

–í Rust –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –Ω–µ —Ç–æ–ª—å–∫–æ –¥–µ–ª–∞—é—Ç –∫–æ–¥ —á–∏—â–µ –∏ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–µ–µ ‚Äî –æ–Ω–∏ —á–∞—Å—Ç–æ **–±—ã—Å—Ç—Ä–µ–µ**, —á–µ–º –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–µ –≤—Ä—É—á–Ω—É—é —Ü–∏–∫–ª—ã!

## –ü–æ—á–µ–º—É –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –±—ã—Ç—å –±—ã—Å—Ç—Ä–µ–µ?

### 1. Zero-cost abstractions

Rust –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –≤ —Ç–∞–∫–æ–π –∂–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥, –∫–∞–∫ –∏ —Ü–∏–∫–ª—ã (–∞ –∏–Ω–æ–≥–¥–∞ –¥–∞–∂–µ –ª—É—á—à–µ):

```rust
// –¶–∏–∫–ª for
let mut sum = 0;
for price in prices.iter() {
    sum += price;
}

// –ò—Ç–µ—Ä–∞—Ç–æ—Ä
let sum: i32 = prices.iter().sum();
```

–û–±–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤ **–∏–¥–µ–Ω—Ç–∏—á–Ω—ã–π** –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥! –ù–æ –∏—Ç–µ—Ä–∞—Ç–æ—Ä:
- –ö–æ—Ä–æ—á–µ –∏ –ø–æ–Ω—è—Ç–Ω–µ–µ
- –ó–∞—â–∏—â—ë–Ω –æ—Ç –æ—à–∏–±–æ–∫ (–Ω–µ—Ç –∏–Ω–¥–µ–∫—Å–æ–≤)
- –î–∞—ë—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### 2. –õ–µ–Ω–∏–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è (Lazy evaluation)

–ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã –Ω–µ –¥–µ–ª–∞—é—Ç —Ä–∞–±–æ—Ç—É –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –Ω—É–∂–µ–Ω:

```rust
#[derive(Debug, Clone)]
struct Trade {
    symbol: String,
    price: f64,
    quantity: i32,
    profit: f64,
}

fn main() {
    let trades = vec![
        Trade { symbol: "BTC".to_string(), price: 42000.0, quantity: 1, profit: 500.0 },
        Trade { symbol: "ETH".to_string(), price: 2500.0, quantity: 10, profit: -200.0 },
        Trade { symbol: "BTC".to_string(), price: 43000.0, quantity: 2, profit: 1000.0 },
        Trade { symbol: "SOL".to_string(), price: 100.0, quantity: 50, profit: 300.0 },
    ];

    // –ò—Ç–µ—Ä–∞—Ç–æ—Ä —Å–æ–∑–¥–∞—ë—Ç –ø–ª–∞–Ω, –Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã—á–∏—Å–ª—è–µ—Ç!
    let profitable_btc = trades.iter()
        .filter(|t| t.profit > 0.0)         // –ü–ª–∞–Ω: "—Ç–æ–ª—å–∫–æ –ø—Ä–∏–±—ã–ª—å–Ω—ã–µ"
        .filter(|t| t.symbol == "BTC");     // –ü–ª–∞–Ω: "—Ç–æ–ª—å–∫–æ BTC"

    // –†–∞–±–æ—Ç–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∑–¥–µ—Å—å, –∫–æ–≥–¥–∞ –Ω—É–∂–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    let count = profitable_btc.count();
    println!("–ü—Ä–∏–±—ã–ª—å–Ω—ã—Ö BTC —Å–¥–µ–ª–æ–∫: {}", count);
}
```

### 3. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞

–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤–∏–¥–∏—Ç –≤—Å—é —Ü–µ–ø–æ—á–∫—É –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏ –º–æ–∂–µ—Ç:
- –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–æ—Ö–æ–¥–æ–≤ –≤ –æ–¥–∏–Ω
- –£–±—Ä–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥—Ä–∞–Ω–∏—Ü –º–∞—Å—Å–∏–≤–∞
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å SIMD –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞)
- –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Ü–∏–∫–ª—ã (loop unrolling)

## –ü—Ä–∏–º–µ—Ä 1: –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–π —Ü–µ–Ω—ã

### –í–µ—Ä—Å–∏—è —Å —Ü–∏–∫–ª–æ–º

```rust
fn average_price_loop(prices: &[f64]) -> Option<f64> {
    if prices.is_empty() {
        return None;
    }

    let mut sum = 0.0;
    for price in prices {
        sum += price;
    }

    Some(sum / prices.len() as f64)
}

fn main() {
    let btc_prices = vec![42000.0, 43500.0, 41800.0, 44200.0, 43000.0];

    match average_price_loop(&btc_prices) {
        Some(avg) => println!("–°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ (—Ü–∏–∫–ª): ${:.2}", avg),
        None => println!("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"),
    }
}
```

### –í–µ—Ä—Å–∏—è —Å –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–º

```rust
fn average_price_iter(prices: &[f64]) -> Option<f64> {
    if prices.is_empty() {
        return None;
    }

    Some(prices.iter().sum::<f64>() / prices.len() as f64)
}

fn main() {
    let btc_prices = vec![42000.0, 43500.0, 41800.0, 44200.0, 43000.0];

    match average_price_iter(&btc_prices) {
        Some(avg) => println!("–°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ (–∏—Ç–µ—Ä–∞—Ç–æ—Ä): ${:.2}", avg),
        None => println!("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"),
    }
}
```

**–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –û–¥–∏–Ω–∞–∫–æ–≤–∞—è! –ù–æ –∏—Ç–µ—Ä–∞—Ç–æ—Ä –∫–æ—Ä–æ—á–µ –∏ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–µ–µ.

## –ü—Ä–∏–º–µ—Ä 2: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è

### –í–µ—Ä—Å–∏—è —Å —Ü–∏–∫–ª–æ–º

```rust
#[derive(Debug)]
struct Order {
    id: u32,
    symbol: String,
    price: f64,
    quantity: i32,
}

// –ü–æ–ª—É—á–∏—Ç—å ID –≤—Å–µ—Ö –∫—Ä—É–ø–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤ BTC
fn get_large_btc_orders_loop(orders: &[Order], min_quantity: i32) -> Vec<u32> {
    let mut result = Vec::new();

    for order in orders {
        if order.symbol == "BTC" && order.quantity >= min_quantity {
            result.push(order.id);
        }
    }

    result
}

fn main() {
    let orders = vec![
        Order { id: 1, symbol: "BTC".to_string(), price: 42000.0, quantity: 5 },
        Order { id: 2, symbol: "ETH".to_string(), price: 2500.0, quantity: 50 },
        Order { id: 3, symbol: "BTC".to_string(), price: 43000.0, quantity: 2 },
        Order { id: 4, symbol: "BTC".to_string(), price: 41500.0, quantity: 10 },
    ];

    let large_btc = get_large_btc_orders_loop(&orders, 5);
    println!("–ö—Ä—É–ø–Ω—ã–µ BTC –∑–∞–∫–∞–∑—ã (—Ü–∏–∫–ª): {:?}", large_btc);
}
```

### –í–µ—Ä—Å–∏—è —Å –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–º

```rust
fn get_large_btc_orders_iter(orders: &[Order], min_quantity: i32) -> Vec<u32> {
    orders.iter()
        .filter(|o| o.symbol == "BTC")
        .filter(|o| o.quantity >= min_quantity)
        .map(|o| o.id)
        .collect()
}

fn main() {
    let orders = vec![
        Order { id: 1, symbol: "BTC".to_string(), price: 42000.0, quantity: 5 },
        Order { id: 2, symbol: "ETH".to_string(), price: 2500.0, quantity: 50 },
        Order { id: 3, symbol: "BTC".to_string(), price: 43000.0, quantity: 2 },
        Order { id: 4, symbol: "BTC".to_string(), price: 41500.0, quantity: 10 },
    ];

    let large_btc = get_large_btc_orders_iter(&orders, 5);
    println!("–ö—Ä—É–ø–Ω—ã–µ BTC –∑–∞–∫–∞–∑—ã (–∏—Ç–µ—Ä–∞—Ç–æ—Ä): {:?}", large_btc);
}
```

**–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –ò—Ç–µ—Ä–∞—Ç–æ—Ä –¥–µ–ª–∞–µ—Ç **–æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥**, —Ü–∏–∫–ª —Ç–æ–∂–µ. –ù–æ –∏—Ç–µ—Ä–∞—Ç–æ—Ä:
- –ë–æ–ª–µ–µ —á–∏—Ç–∞–µ–º (–¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—Ç–∏–ª—å)
- –õ–µ–≥—á–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å (–¥–æ–±–∞–≤–∏—Ç—å –µ—â—ë –æ–¥–∏–Ω `filter`)
- –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –ª—É—á—à–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å

## –ü—Ä–∏–º–µ—Ä 3: –ë–µ–Ω—á–º–∞—Ä–∫ ‚Äî –≥–¥–µ –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ

```rust
use std::time::Instant;

#[derive(Debug, Clone)]
struct Candle {
    timestamp: u64,
    open: f64,
    high: f64,
    low: f64,
    close: f64,
    volume: f64,
}

impl Candle {
    fn new(timestamp: u64, close: f64) -> Self {
        Self {
            timestamp,
            open: close,
            high: close * 1.01,
            low: close * 0.99,
            close,
            volume: 1000.0,
        }
    }
}

// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ–Ω—Ç–Ω–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Å–≤–µ—á–æ–π
fn calculate_returns_loop(candles: &[Candle]) -> Vec<f64> {
    let mut returns = Vec::with_capacity(candles.len() - 1);

    for i in 1..candles.len() {
        let return_pct = (candles[i].close - candles[i - 1].close) / candles[i - 1].close;
        returns.push(return_pct);
    }

    returns
}

fn calculate_returns_iter(candles: &[Candle]) -> Vec<f64> {
    candles.windows(2)
        .map(|pair| (pair[1].close - pair[0].close) / pair[0].close)
        .collect()
}

fn main() {
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
    let candles: Vec<Candle> = (0..100_000)
        .map(|i| Candle::new(i, 42000.0 + (i as f64 * 0.5)))
        .collect();

    // –ë–µ–Ω—á–º–∞—Ä–∫ —Ü–∏–∫–ª–∞
    let start = Instant::now();
    let returns_loop = calculate_returns_loop(&candles);
    let duration_loop = start.elapsed();

    // –ë–µ–Ω—á–º–∞—Ä–∫ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞
    let start = Instant::now();
    let returns_iter = calculate_returns_iter(&candles);
    let duration_iter = start.elapsed();

    println!("=== –ë–µ–Ω—á–º–∞—Ä–∫: –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏ ===");
    println!("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π: {}", candles.len());
    println!("–¶–∏–∫–ª for:  {:?} ({} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤)", duration_loop, returns_loop.len());
    println!("–ò—Ç–µ—Ä–∞—Ç–æ—Ä:  {:?} ({} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤)", duration_iter, returns_iter.len());

    if duration_iter < duration_loop {
        let speedup = duration_loop.as_nanos() as f64 / duration_iter.as_nanos() as f64;
        println!("‚úÖ –ò—Ç–µ—Ä–∞—Ç–æ—Ä –±—ã—Å—Ç—Ä–µ–µ –≤ {:.2}x —Ä–∞–∑", speedup);
    } else {
        println!("‚öñÔ∏è  –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–∏–º–µ—Ä–Ω–æ –æ–¥–∏–Ω–∞–∫–æ–≤–∞—è");
    }
}
```

## –ö–æ–≥–¥–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –º–µ–¥–ª–µ–Ω–Ω–µ–µ?

### 1. –°–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Å —Ä–∞–Ω–Ω–∏–º –≤—ã—Ö–æ–¥–æ–º

```rust
// –ü–æ–∏—Å–∫ –ø–µ—Ä–≤–æ–π —É–±—ã—Ç–æ—á–Ω–æ–π —Å–¥–µ–ª–∫–∏ —Å –≤—ã—Ö–æ–¥–æ–º
fn find_first_loss_loop(trades: &[Trade]) -> Option<&Trade> {
    for trade in trades {
        if trade.profit < 0.0 {
            return Some(trade);  // –†–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥!
        }
    }
    None
}

// –° –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–º ‚Äî —Ç–æ–∂–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –±–ª–∞–≥–æ–¥–∞—Ä—è .find()
fn find_first_loss_iter(trades: &[Trade]) -> Option<&Trade> {
    trades.iter().find(|t| t.profit < 0.0)
}
```

**–û–±–∞ –æ–¥–∏–Ω–∞–∫–æ–≤–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã** –±–ª–∞–≥–æ–¥–∞—Ä—è lazy evaluation –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤.

### 2. –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞

```rust
// –ü–æ–¥—Å—á—ë—Ç —Å–µ—Ä–∏–π –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö —Å–¥–µ–ª–æ–∫
fn count_winning_streaks_loop(trades: &[Trade]) -> Vec<usize> {
    let mut streaks = Vec::new();
    let mut current_streak = 0;

    for trade in trades {
        if trade.profit > 0.0 {
            current_streak += 1;
        } else {
            if current_streak > 0 {
                streaks.push(current_streak);
                current_streak = 0;
            }
        }
    }

    if current_streak > 0 {
        streaks.push(current_streak);
    }

    streaks
}
```

–ó–¥–µ—Å—å —Ü–∏–∫–ª **–ø—Ä–æ—â–µ –∏ –ø–æ–Ω—è—Ç–Ω–µ–µ**, —á–µ–º –ø–æ–ø—ã—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `fold()` –∏–ª–∏ `scan()`.

## –°—Ä–∞–≤–Ω–µ–Ω–∏–µ: –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å vs –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

| –û–ø–µ—Ä–∞—Ü–∏—è | –¶–∏–∫–ª for | –ò—Ç–µ—Ä–∞—Ç–æ—Ä | –ü–æ–±–µ–¥–∏—Ç–µ–ª—å |
|----------|----------|----------|------------|
| –ü—Ä–æ—Å—Ç–æ–π –ø—Ä–æ—Ö–æ–¥ | `for x in iter` | `.iter()` | ü§ù –û–¥–∏–Ω–∞–∫–æ–≤–æ |
| –°—É–º–º–∞ | –†—É—á–Ω–æ–π —Å—á—ë—Ç—á–∏–∫ | `.sum()` | ‚úÖ –ò—Ç–µ—Ä–∞—Ç–æ—Ä (–∫–æ—Ä–æ—á–µ) |
| –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è | `if` –≤–Ω—É—Ç—Ä–∏ | `.filter()` | ‚úÖ –ò—Ç–µ—Ä–∞—Ç–æ—Ä (—á–∏—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å) |
| –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è | –†—É—á–Ω–æ–π `Vec::push` | `.map().collect()` | ‚úÖ –ò—Ç–µ—Ä–∞—Ç–æ—Ä |
| –°–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞ | –Ø–≤–Ω—ã–µ —É—Å–ª–æ–≤–∏—è | `fold()`/`scan()` | ‚úÖ –¶–∏–∫–ª (–ø–æ–Ω—è—Ç–Ω–µ–µ) |
| –†–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥ | `break`/`return` | `.find()`/`.any()` | ü§ù –û–¥–∏–Ω–∞–∫–æ–≤–æ |

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: –∞–Ω–∞–ª–∏–∑ –ø–æ—Ä—Ç—Ñ–µ–ª—è

```rust
#[derive(Debug, Clone)]
struct Position {
    symbol: String,
    quantity: f64,
    entry_price: f64,
    current_price: f64,
}

impl Position {
    fn profit(&self) -> f64 {
        (self.current_price - self.entry_price) * self.quantity
    }

    fn profit_pct(&self) -> f64 {
        (self.current_price - self.entry_price) / self.entry_price
    }
}

fn analyze_portfolio(positions: &[Position]) {
    // 1. –û–±—â–∞—è –ø—Ä–∏–±—ã–ª—å/—É–±—ã—Ç–æ–∫ (–∏—Ç–µ—Ä–∞—Ç–æ—Ä)
    let total_pnl: f64 = positions.iter()
        .map(|p| p.profit())
        .sum();

    // 2. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
    let profitable_count = positions.iter()
        .filter(|p| p.profit() > 0.0)
        .count();

    // 3. –°—Ä–µ–¥–Ω–∏–π –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª–∏ (—Ç–æ–ª—å–∫–æ –ø—Ä–∏–±—ã–ª—å–Ω—ã–µ)
    let avg_profit_pct = positions.iter()
        .filter(|p| p.profit() > 0.0)
        .map(|p| p.profit_pct())
        .sum::<f64>() / profitable_count.max(1) as f64;

    // 4. –°–∞–º–∞—è —É–±—ã—Ç–æ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
    let worst_position = positions.iter()
        .min_by(|a, b| a.profit().partial_cmp(&b.profit()).unwrap());

    // 5. –°–∏–º–≤–æ–ª—ã –ø–æ–∑–∏—Ü–∏–π —Å —É–±—ã—Ç–∫–æ–º > 10%
    let heavy_losses: Vec<&str> = positions.iter()
        .filter(|p| p.profit_pct() < -0.10)
        .map(|p| p.symbol.as_str())
        .collect();

    println!("=== –ê–Ω–∞–ª–∏–∑ –ø–æ—Ä—Ç—Ñ–µ–ª—è ===");
    println!("–û–±—â–∏–π P&L: ${:.2}", total_pnl);
    println!("–ü—Ä–∏–±—ã–ª—å–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π: {} –∏–∑ {}", profitable_count, positions.len());
    println!("–°—Ä–µ–¥–Ω—è—è –ø—Ä–∏–±—ã–ª—å: {:.2}%", avg_profit_pct * 100.0);

    if let Some(worst) = worst_position {
        println!("–•—É–¥—à–∞—è –ø–æ–∑–∏—Ü–∏—è: {} (${:.2})", worst.symbol, worst.profit());
    }

    if !heavy_losses.is_empty() {
        println!("–£–±—ã—Ç–∫–∏ > 10%: {:?}", heavy_losses);
    }
}

fn main() {
    let portfolio = vec![
        Position { symbol: "BTC".to_string(), quantity: 2.0, entry_price: 40000.0, current_price: 43000.0 },
        Position { symbol: "ETH".to_string(), quantity: 50.0, entry_price: 2800.0, current_price: 2500.0 },
        Position { symbol: "SOL".to_string(), quantity: 100.0, entry_price: 120.0, current_price: 105.0 },
        Position { symbol: "AAPL".to_string(), quantity: 10.0, entry_price: 180.0, current_price: 185.0 },
    ];

    analyze_portfolio(&portfolio);
}
```

## –ß—Ç–æ –º—ã —É–∑–Ω–∞–ª–∏

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –û–ø–∏—Å–∞–Ω–∏–µ |
|-----------|----------|
| **Zero-cost abstractions** | –ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥ |
| **Lazy evaluation** | –ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã –Ω–µ –≤—ã–ø–æ–ª–Ω—è—é—Ç —Ä–∞–±–æ—Ç—É –¥–æ –≤—ã–∑–æ–≤–∞ consuming –º–µ—Ç–æ–¥–∞ |
| **–¶–µ–ø–æ—á–∫–∏ –º–µ—Ç–æ–¥–æ–≤** | `.filter().map().collect()` ‚Äî —á–∏—Ç–∞–±–µ–ª—å–Ω–µ–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ |
| **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞** | –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –ª—É—á—à–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã |
| **–í—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** | –î–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—Ç–∏–ª—å: "—á—Ç–æ –¥–µ–ª–∞—Ç—å", –∞ –Ω–µ "–∫–∞–∫ –¥–µ–ª–∞—Ç—å" |
| **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** | –ù–µ—Ç —Ä—É—á–Ω—ã—Ö –∏–Ω–¥–µ–∫—Å–æ–≤ ‚Äî –Ω–µ—Ç –æ—à–∏–±–æ–∫ –≤—ã—Ö–æ–¥–∞ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã |
| **windows()** | –ò—Ç–µ—Ä–∞—Ç–æ—Ä –ø–æ —Å–∫–æ–ª—å–∑—è—â–µ–º—É –æ–∫–Ω—É ‚Äî —É–¥–æ–±–Ω–æ –¥–ª—è –ø–∞—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ |
| **–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–∏–∫–ª—ã** | –°–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Å –∏–∑–º–µ–Ω—è–µ–º—ã–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º |

## –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ

1. **–ë–µ–Ω—á–º–∞—Ä–∫ SMA**: –ù–∞–ø–∏—à–∏ –¥–≤–µ –≤–µ—Ä—Å–∏–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–æ—Å—Ç–æ–π —Å–∫–æ–ª—å–∑—è—â–µ–π —Å—Ä–µ–¥–Ω–µ–π:
   - –° —Ü–∏–∫–ª–æ–º `for`
   - –° –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞–º–∏ (–∏—Å–ø–æ–ª—å–∑—É–π `windows()`)

   –ó–∞–º–µ—Ä—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–∞ –º–∞—Å—Å–∏–≤–µ –∏–∑ 1 –º–∏–ª–ª–∏–æ–Ω–∞ —Ü–µ–Ω.

2. **–ê–Ω–∞–ª–∏–∑ —Å–¥–µ–ª–æ–∫**: –î–ª—è –º–∞—Å—Å–∏–≤–∞ —Å–¥–µ–ª–æ–∫ —Ä–µ–∞–ª–∏–∑—É–π —Å –ø–æ–º–æ—â—å—é –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤:
   - –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –®–∞—Ä–ø–∞ (Sharpe ratio)
   - –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø—Ä–æ—Å–∞–¥–∫—É (max drawdown)
   - Win rate (–ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö —Å–¥–µ–ª–æ–∫)
   - –°—Ä–µ–¥–Ω–∏–π –≤—ã–∏–≥—Ä—ã—à vs —Å—Ä–µ–¥–Ω–∏–π –ø—Ä–æ–∏–≥—Ä—ã—à

3. **–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–¥—Ö–æ–¥–æ–≤**: –†–µ–∞–ª–∏–∑—É–π —Ñ—É–Ω–∫—Ü–∏—é `find_best_strategy()`, –∫–æ—Ç–æ—Ä–∞—è:
   - –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –º–∞—Å—Å–∏–≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
   - –§–∏–ª—å—Ç—Ä—É–µ—Ç –ø–æ Sharpe > 1.0 –∏ drawdown < 20%
   - –°–æ—Ä—Ç–∏—Ä—É–µ—Ç –ø–æ –ø—Ä–∏–±—ã–ª–∏
   - –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ø-3 —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏

   –†–µ–∞–ª–∏–∑—É–π **–¥–≤—É–º—è —Å–ø–æ—Å–æ–±–∞–º–∏**: —Å —Ü–∏–∫–ª–∞–º–∏ –∏ —Å –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞–º–∏. –ö–∞–∫–æ–π –∫–æ–¥ –ø–æ–Ω—è—Ç–Ω–µ–µ?

4. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ü–µ–ø–æ—á–µ–∫**: –ù–∞–π–¥–∏ –≤ —Å–≤–æ—ë–º –∫–æ–¥–µ –º–µ—Å—Ç–∞, –≥–¥–µ –º–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ü–∏–∫–ª–æ–≤ –æ–¥–Ω–æ–π —Ü–µ–ø–æ—á–∫–æ–π –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤. –ò–∑–º–µ—Ä—å —É–ª—É—á—à–µ–Ω–∏–µ —á–∏—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç–∏ –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.

## –ù–∞–≤–∏–≥–∞—Ü–∏—è

[‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å](../294-overfitting-strategy-optimization/ru.md)
