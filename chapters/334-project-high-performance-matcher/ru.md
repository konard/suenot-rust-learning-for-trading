# –î–µ–Ω—å 334: –ü—Ä–æ–µ–∫—Ç ‚Äî –í—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –º–∞—Ç—á–µ—Ä

## –í–≤–µ–¥–µ–Ω–∏–µ

–≠—Ç–æ **–ø—Ä–æ–µ–∫—Ç–Ω–∞—è –≥–ª–∞–≤–∞**, –∫–æ—Ç–æ—Ä–∞—è –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –∑–Ω–∞–Ω–∏—è –∑–∞ –º–µ—Å—è—Ü –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –º–∏–Ω–∏-–ø—Ä–æ–µ–∫—Ç. –ú—ã —Å–æ–∑–¥–∞–¥–∏–º **–≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –º–∞—Ç—á–µ—Ä –æ—Ä–¥–µ—Ä–æ–≤** ‚Äî —Å–µ—Ä–¥—Ü–µ –ª—é–±–æ–π —Ç–æ—Ä–≥–æ–≤–æ–π –±–∏—Ä–∂–∏, –ø—Ä–∏–º–µ–Ω—è—è —Ç–µ—Ö–Ω–∏–∫–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, –∏–∑—É—á–µ–Ω–Ω—ã–µ –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ.

## –¢–æ—Ä–≥–æ–≤–∞—è –∞–Ω–∞–ª–æ–≥–∏—è

–ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ —Å–µ–±–µ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π —Ä—ã–Ω–æ–∫ —Ü–µ–Ω–Ω—ã—Ö –±—É–º–∞–≥ –≤ —á–∞—Å –ø–∏–∫. –¢—ã—Å—è—á–∏ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ –≤—ã–∫—Ä–∏–∫–∏–≤–∞—é—Ç —Å–≤–æ–∏ –æ—Ä–¥–µ—Ä–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ:

```
üó£Ô∏è "–ü–æ–∫—É–ø–∞—é 100 BTC –ø–æ $50,000!"
üó£Ô∏è "–ü—Ä–æ–¥–∞—é 50 BTC –ø–æ $50,000!"
üó£Ô∏è "–ü–æ–∫—É–ø–∞—é 200 ETH –ø–æ $3,000!"
...
```

**–ú–∞—Ç—á–µ—Ä** ‚Äî —ç—Ç–æ "—Å—É–ø–µ—Ä—Å–ª—É—Ö" –±–∏—Ä–∂–∏, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω:
1. –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ —É—Å–ª—ã—à–∞—Ç—å –∫–∞–∂–¥—ã–π –æ—Ä–¥–µ—Ä
2. –ù–∞–π—Ç–∏ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –æ—Ä–¥–µ—Ä–∞ (–ø–æ–∫—É–ø–∞—Ç–µ–ª—å –≥–æ—Ç–æ–≤ –ø–ª–∞—Ç–∏—Ç—å >= —Ü–µ–Ω–∞ –ø—Ä–æ–¥–∞–≤—Ü–∞)
3. –ò—Å–ø–æ–ª–Ω–∏—Ç—å —Å–¥–µ–ª–∫—É –∑–∞ –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥—ã
4. –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –º–∏–ª–ª–∏–æ–Ω—ã —Ç–∞–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –≤ —Å–µ–∫—É–Ω–¥—É

| –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ | –¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ |
|----------------|------------|
| –ó–∞–¥–µ—Ä–∂–∫–∞ (Latency) | < 1 –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥—ã |
| –ü—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å | > 1 –º–ª–Ω –æ—Ä–¥–µ—Ä–æ–≤/—Å–µ–∫ |
| –î–µ—Ç–µ—Ä–º–∏–Ω–∏–∑–º | –ü—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ–µ –≤—Ä–µ–º—è |
| –ê–ª–ª–æ–∫–∞—Ü–∏–∏ | –ú–∏–Ω–∏–º—É–º –∏–ª–∏ –Ω–æ–ª—å |
| –ü–æ—Ä—è–¥–æ–∫ | –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ FIFO |

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–∞—Ç—á–µ—Ä–∞

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MATCHING ENGINE                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  PARSER     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  VALIDATOR  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  SEQUENCER  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Zero-copy   ‚îÇ    ‚îÇ Pre-alloc   ‚îÇ    ‚îÇ Lock-free   ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ          ‚îÇ                                    ‚îÇ           ‚îÇ
‚îÇ          ‚ñº                                    ‚ñº           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ              ORDER BOOK (per symbol)             ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   BIDS     ‚îÇ         ‚îÇ   ASKS     ‚îÇ          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ BTreeMap   ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ BTreeMap   ‚îÇ          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ max-heap   ‚îÇ MATCH!  ‚îÇ min-heap   ‚îÇ          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ          ‚îÇ                                    ‚îÇ           ‚îÇ
‚îÇ          ‚ñº                                    ‚ñº           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  EXECUTOR   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  PUBLISHER  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  PERSISTER  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Arena alloc‚îÇ    ‚îÇ Ring buffer ‚îÇ    ‚îÇ Async batch ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## –ß–∞—Å—Ç—å 1: –ë–∞–∑–æ–≤—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –∞–ª–ª–æ–∫–∞—Ü–∏—è–º–∏

```rust
use std::cmp::Ordering;
use std::collections::BTreeMap;

/// –°—Ç–æ—Ä–æ–Ω–∞ –æ—Ä–¥–µ—Ä–∞
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Side {
    Bid = 0,  // –ü–æ–∫—É–ø–∫–∞
    Ask = 1,  // –ü—Ä–æ–¥–∞–∂–∞
}

/// –¢–∏–ø –æ—Ä–¥–µ—Ä–∞
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum OrderType {
    Limit = 0,
    Market = 1,
    IoC = 2,    // Immediate or Cancel
    FoK = 3,    // Fill or Kill
}

/// –û—Ä–¥–µ—Ä ‚Äî –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –≤ –∫—ç—à-–ª–∏–Ω–∏–∏ (64 –±–∞–π—Ç–∞)
#[derive(Debug, Clone)]
#[repr(C)]
pub struct Order {
    pub id: u64,            // 8 –±–∞–π—Ç
    pub price: u64,         // 8 –±–∞–π—Ç (–≤ "—Ç–∏–∫–∞—Ö" –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏)
    pub quantity: u64,      // 8 –±–∞–π—Ç
    pub filled: u64,        // 8 –±–∞–π—Ç
    pub timestamp: u64,     // 8 –±–∞–π—Ç
    pub side: Side,         // 1 –±–∞–π—Ç
    pub order_type: OrderType, // 1 –±–∞–π—Ç
    pub symbol_id: u16,     // 2 –±–∞–π—Ç–∞
    _padding: [u8; 4],      // 4 –±–∞–π—Ç–∞ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
}                           // –ò—Ç–æ–≥–æ: 48 –±–∞–π—Ç

impl Order {
    #[inline]
    pub fn new(
        id: u64,
        price: u64,
        quantity: u64,
        side: Side,
        order_type: OrderType,
        symbol_id: u16,
        timestamp: u64,
    ) -> Self {
        Order {
            id,
            price,
            quantity,
            filled: 0,
            timestamp,
            side,
            order_type,
            symbol_id,
            _padding: [0; 4],
        }
    }

    #[inline]
    pub fn remaining(&self) -> u64 {
        self.quantity - self.filled
    }

    #[inline]
    pub fn is_filled(&self) -> bool {
        self.filled >= self.quantity
    }
}

/// –†–µ–∑—É–ª—å—Ç–∞—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è ‚Äî –±–µ–∑ –∞–ª–ª–æ–∫–∞—Ü–∏–π
#[derive(Debug, Clone, Copy)]
pub struct Fill {
    pub maker_order_id: u64,
    pub taker_order_id: u64,
    pub price: u64,
    pub quantity: u64,
    pub timestamp: u64,
}

fn main() {
    println!("Size of Order: {} bytes", std::mem::size_of::<Order>());
    println!("Size of Fill: {} bytes", std::mem::size_of::<Fill>());

    let order = Order::new(
        1,
        50000_00, // $50,000.00 –≤ —Ü–µ–Ω—Ç–∞—Ö
        100,
        Side::Bid,
        OrderType::Limit,
        1, // BTC/USDT
        1234567890,
    );

    println!("Order: {:?}", order);
    println!("Remaining: {}", order.remaining());
}
```

## –ß–∞—Å—Ç—å 2: –£—Ä–æ–≤–µ–Ω—å —Ü–µ–Ω—ã —Å –ø—É–ª–æ–º –ø–∞–º—è—Ç–∏

```rust
use std::collections::VecDeque;

/// –ü—Ä–µ–¥–∞–ª–ª–æ—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—É–ª –æ—Ä–¥–µ—Ä–æ–≤ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∞–ª–ª–æ–∫–∞—Ü–∏–π
pub struct OrderPool {
    orders: Vec<Order>,
    free_indices: Vec<usize>,
}

impl OrderPool {
    pub fn with_capacity(capacity: usize) -> Self {
        OrderPool {
            orders: Vec::with_capacity(capacity),
            free_indices: Vec::with_capacity(capacity),
        }
    }

    #[inline]
    pub fn allocate(&mut self, order: Order) -> usize {
        if let Some(idx) = self.free_indices.pop() {
            self.orders[idx] = order;
            idx
        } else {
            let idx = self.orders.len();
            self.orders.push(order);
            idx
        }
    }

    #[inline]
    pub fn deallocate(&mut self, idx: usize) {
        self.free_indices.push(idx);
    }

    #[inline]
    pub fn get(&self, idx: usize) -> Option<&Order> {
        self.orders.get(idx)
    }

    #[inline]
    pub fn get_mut(&mut self, idx: usize) -> Option<&mut Order> {
        self.orders.get_mut(idx)
    }
}

/// –£—Ä–æ–≤–µ–Ω—å —Ü–µ–Ω—ã ‚Äî —Ö—Ä–∞–Ω–∏—Ç –∏–Ω–¥–µ–∫—Å—ã –≤ –ø—É–ª–µ
#[derive(Debug)]
pub struct PriceLevel {
    pub price: u64,
    pub total_quantity: u64,
    order_indices: VecDeque<usize>,
}

impl PriceLevel {
    #[inline]
    pub fn new(price: u64) -> Self {
        PriceLevel {
            price,
            total_quantity: 0,
            order_indices: VecDeque::with_capacity(64),
        }
    }

    #[inline]
    pub fn add_order(&mut self, idx: usize, quantity: u64) {
        self.order_indices.push_back(idx);
        self.total_quantity += quantity;
    }

    #[inline]
    pub fn front(&self) -> Option<usize> {
        self.order_indices.front().copied()
    }

    #[inline]
    pub fn pop_front(&mut self) -> Option<usize> {
        self.order_indices.pop_front()
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        self.order_indices.is_empty()
    }

    #[inline]
    pub fn order_count(&self) -> usize {
        self.order_indices.len()
    }
}

fn main() {
    let mut pool = OrderPool::with_capacity(1000);

    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä–∞
    let order1 = Order::new(1, 50000_00, 100, Side::Bid, OrderType::Limit, 1, 1000);
    let order2 = Order::new(2, 50000_00, 200, Side::Bid, OrderType::Limit, 1, 1001);

    let idx1 = pool.allocate(order1);
    let idx2 = pool.allocate(order2);

    let mut level = PriceLevel::new(50000_00);
    level.add_order(idx1, 100);
    level.add_order(idx2, 200);

    println!("Price level: {} cents", level.price);
    println!("Total quantity: {}", level.total_quantity);
    println!("Order count: {}", level.order_count());
}
```

## –ß–∞—Å—Ç—å 3: –í—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–∞—è –∫–Ω–∏–≥–∞ –æ—Ä–¥–µ—Ä–æ–≤

```rust
use std::collections::BTreeMap;
use std::collections::VecDeque;
use std::cmp::Reverse;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Side {
    Bid = 0,
    Ask = 1,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum OrderType {
    Limit = 0,
    Market = 1,
}

#[derive(Debug, Clone)]
#[repr(C)]
pub struct Order {
    pub id: u64,
    pub price: u64,
    pub quantity: u64,
    pub filled: u64,
    pub timestamp: u64,
    pub side: Side,
    pub order_type: OrderType,
    pub symbol_id: u16,
    _padding: [u8; 4],
}

impl Order {
    pub fn new(id: u64, price: u64, quantity: u64, side: Side,
               order_type: OrderType, symbol_id: u16, timestamp: u64) -> Self {
        Order { id, price, quantity, filled: 0, timestamp, side, order_type, symbol_id, _padding: [0; 4] }
    }

    #[inline]
    pub fn remaining(&self) -> u64 { self.quantity - self.filled }
}

#[derive(Debug, Clone, Copy)]
pub struct Fill {
    pub maker_order_id: u64,
    pub taker_order_id: u64,
    pub price: u64,
    pub quantity: u64,
    pub timestamp: u64,
}

pub struct PriceLevel {
    pub price: u64,
    pub total_quantity: u64,
    orders: VecDeque<Order>,
}

impl PriceLevel {
    pub fn new(price: u64) -> Self {
        PriceLevel { price, total_quantity: 0, orders: VecDeque::with_capacity(32) }
    }

    #[inline]
    pub fn add_order(&mut self, order: Order) {
        self.total_quantity += order.remaining();
        self.orders.push_back(order);
    }

    #[inline]
    pub fn front_mut(&mut self) -> Option<&mut Order> { self.orders.front_mut() }

    #[inline]
    pub fn pop_front(&mut self) -> Option<Order> { self.orders.pop_front() }

    #[inline]
    pub fn is_empty(&self) -> bool { self.orders.is_empty() }
}

/// –í—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–∞—è –∫–Ω–∏–≥–∞ –æ—Ä–¥–µ—Ä–æ–≤
pub struct OrderBook {
    pub symbol_id: u16,
    /// Bids: –∏—Å–ø–æ–ª—å–∑—É–µ–º Reverse –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –ø–æ —É–±—ã–≤–∞–Ω–∏—é
    bids: BTreeMap<Reverse<u64>, PriceLevel>,
    /// Asks: —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
    asks: BTreeMap<u64, PriceLevel>,
    /// –°—á—ë—Ç—á–∏–∫ –æ—Ä–¥–µ—Ä–æ–≤
    order_count: u64,
    /// –ë—É—Ñ–µ—Ä –¥–ª—è fills (–∏–∑–±–µ–≥–∞–µ–º –∞–ª–ª–æ–∫–∞—Ü–∏–π)
    fills_buffer: Vec<Fill>,
}

impl OrderBook {
    pub fn new(symbol_id: u16) -> Self {
        OrderBook {
            symbol_id,
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            order_count: 0,
            fills_buffer: Vec::with_capacity(1024),
        }
    }

    /// –õ—É—á—à–∏–π bid
    #[inline]
    pub fn best_bid(&self) -> Option<u64> {
        self.bids.keys().next().map(|r| r.0)
    }

    /// –õ—É—á—à–∏–π ask
    #[inline]
    pub fn best_ask(&self) -> Option<u64> {
        self.asks.keys().next().copied()
    }

    /// –°–ø—Ä–µ–¥
    #[inline]
    pub fn spread(&self) -> Option<u64> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) if ask > bid => Some(ask - bid),
            _ => None,
        }
    }

    /// –î–æ–±–∞–≤–∏—Ç—å –ª–∏–º–∏—Ç–Ω—ã–π –æ—Ä–¥–µ—Ä —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –º–∞—Ç—á–∏–Ω–≥–æ–º
    pub fn add_limit_order(&mut self, mut order: Order) -> Vec<Fill> {
        self.fills_buffer.clear();
        let timestamp = order.timestamp;

        match order.side {
            Side::Bid => {
                // –ü—ã—Ç–∞–µ–º—Å—è –º–∞—Ç—á–∏—Ç—å —Å asks
                while order.remaining() > 0 {
                    let best_ask = match self.asks.first_entry() {
                        Some(entry) if *entry.key() <= order.price => entry,
                        _ => break,
                    };

                    let ask_price = *best_ask.key();
                    let level = best_ask.into_mut();

                    while order.remaining() > 0 && !level.is_empty() {
                        let maker = level.front_mut().unwrap();
                        let fill_qty = order.remaining().min(maker.remaining());
                        let maker_id = maker.id;
                        let maker_price = maker.price;

                        maker.filled += fill_qty;
                        order.filled += fill_qty;

                        let maker_done = maker.remaining() == 0;

                        let fill = Fill {
                            maker_order_id: maker_id,
                            taker_order_id: order.id,
                            price: maker_price,
                            quantity: fill_qty,
                            timestamp,
                        };
                        self.fills_buffer.push(fill);

                        level.total_quantity -= fill_qty;

                        if maker_done {
                            level.pop_front();
                        }
                    }

                    if level.is_empty() {
                        self.asks.remove(&ask_price);
                    }
                }

                // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –≤ –∫–Ω–∏–≥—É
                if order.remaining() > 0 {
                    self.bids
                        .entry(Reverse(order.price))
                        .or_insert_with(|| PriceLevel::new(order.price))
                        .add_order(order);
                    self.order_count += 1;
                }
            }
            Side::Ask => {
                // –ü—ã—Ç–∞–µ–º—Å—è –º–∞—Ç—á–∏—Ç—å —Å bids
                while order.remaining() > 0 {
                    let best_bid = match self.bids.first_entry() {
                        Some(entry) if entry.key().0 >= order.price => entry,
                        _ => break,
                    };

                    let bid_price = best_bid.key().0;
                    let level = best_bid.into_mut();

                    while order.remaining() > 0 && !level.is_empty() {
                        let maker = level.front_mut().unwrap();
                        let fill_qty = order.remaining().min(maker.remaining());
                        let maker_id = maker.id;
                        let maker_price = maker.price;

                        maker.filled += fill_qty;
                        order.filled += fill_qty;

                        let maker_done = maker.remaining() == 0;

                        let fill = Fill {
                            maker_order_id: maker_id,
                            taker_order_id: order.id,
                            price: maker_price,
                            quantity: fill_qty,
                            timestamp,
                        };
                        self.fills_buffer.push(fill);

                        level.total_quantity -= fill_qty;

                        if maker_done {
                            level.pop_front();
                        }
                    }

                    if level.is_empty() {
                        self.bids.remove(&Reverse(bid_price));
                    }
                }

                // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –≤ –∫–Ω–∏–≥—É
                if order.remaining() > 0 {
                    self.asks
                        .entry(order.price)
                        .or_insert_with(|| PriceLevel::new(order.price))
                        .add_order(order);
                    self.order_count += 1;
                }
            }
        }

        self.fills_buffer.clone()
    }

    /// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–Ω–∏–≥–∏
    pub fn stats(&self) -> BookStats {
        BookStats {
            bid_levels: self.bids.len(),
            ask_levels: self.asks.len(),
            best_bid: self.best_bid(),
            best_ask: self.best_ask(),
            spread: self.spread(),
            total_orders: self.order_count,
        }
    }
}

#[derive(Debug)]
pub struct BookStats {
    pub bid_levels: usize,
    pub ask_levels: usize,
    pub best_bid: Option<u64>,
    pub best_ask: Option<u64>,
    pub spread: Option<u64>,
    pub total_orders: u64,
}

fn main() {
    let mut book = OrderBook::new(1);
    let mut order_id = 1u64;

    // –î–æ–±–∞–≤–ª—è–µ–º asks (–ø—Ä–æ–¥–∞–≤—Ü—ã)
    for i in 0..5 {
        let price = 50100 + i * 10; // $501.00, $501.10, ...
        let order = Order::new(order_id, price, 100, Side::Ask, OrderType::Limit, 1, order_id);
        order_id += 1;
        book.add_limit_order(order);
    }

    // –î–æ–±–∞–≤–ª—è–µ–º bids (–ø–æ–∫—É–ø–∞—Ç–µ–ª–∏)
    for i in 0..5 {
        let price = 50000 - i * 10; // $500.00, $499.90, ...
        let order = Order::new(order_id, price, 100, Side::Bid, OrderType::Limit, 1, order_id);
        order_id += 1;
        book.add_limit_order(order);
    }

    println!("=== Order Book Stats ===");
    let stats = book.stats();
    println!("{:?}", stats);

    // –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –æ—Ä–¥–µ—Ä –Ω–∞ –ø–æ–∫—É–ø–∫—É ‚Äî –¥–æ–ª–∂–µ–Ω –∑–∞–º–∞—Ç—á–∏—Ç—å—Å—è
    println!("\n=== Matching Buy Order ===");
    let aggressive_buy = Order::new(order_id, 50120, 250, Side::Bid, OrderType::Limit, 1, order_id);
    let fills = book.add_limit_order(aggressive_buy);

    for fill in &fills {
        println!("Fill: {} units @ {} (maker: {}, taker: {})",
            fill.quantity, fill.price, fill.maker_order_id, fill.taker_order_id);
    }

    println!("\n=== Updated Stats ===");
    println!("{:?}", book.stats());
}
```

## –ß–∞—Å—Ç—å 4: Lock-free –æ—á–µ—Ä–µ–¥—å –æ—Ä–¥–µ—Ä–æ–≤

–î–ª—è –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º lock-free —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:

```rust
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::cell::UnsafeCell;

/// Lock-free Single Producer Single Consumer –∫–æ–ª—å—Ü–µ–≤–æ–π –±—É—Ñ–µ—Ä
pub struct SpscQueue<T> {
    buffer: Vec<UnsafeCell<Option<T>>>,
    capacity: usize,
    head: AtomicUsize,  // –ò–Ω–¥–µ–∫—Å –¥–ª—è —á—Ç–µ–Ω–∏—è
    tail: AtomicUsize,  // –ò–Ω–¥–µ–∫—Å –¥–ª—è –∑–∞–ø–∏—Å–∏
}

// –ë–µ–∑–æ–ø–∞—Å–Ω–æ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –º–µ–∂–¥—É –ø–æ—Ç–æ–∫–∞–º–∏
unsafe impl<T: Send> Send for SpscQueue<T> {}
unsafe impl<T: Send> Sync for SpscQueue<T> {}

impl<T> SpscQueue<T> {
    pub fn with_capacity(capacity: usize) -> Self {
        let capacity = capacity.next_power_of_two();
        let mut buffer = Vec::with_capacity(capacity);
        for _ in 0..capacity {
            buffer.push(UnsafeCell::new(None));
        }

        SpscQueue {
            buffer,
            capacity,
            head: AtomicUsize::new(0),
            tail: AtomicUsize::new(0),
        }
    }

    /// –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–ø–∏—Å–∏ (producer)
    pub fn try_push(&self, value: T) -> Result<(), T> {
        let tail = self.tail.load(Ordering::Relaxed);
        let next_tail = (tail + 1) & (self.capacity - 1);

        if next_tail == self.head.load(Ordering::Acquire) {
            return Err(value); // –ë—É—Ñ–µ—Ä –ø–æ–ª–æ–Ω
        }

        unsafe {
            *self.buffer[tail].get() = Some(value);
        }

        self.tail.store(next_tail, Ordering::Release);
        Ok(())
    }

    /// –ü–æ–ø—ã—Ç–∫–∞ —á—Ç–µ–Ω–∏—è (consumer)
    pub fn try_pop(&self) -> Option<T> {
        let head = self.head.load(Ordering::Relaxed);

        if head == self.tail.load(Ordering::Acquire) {
            return None; // –ë—É—Ñ–µ—Ä –ø—É—Å—Ç
        }

        let value = unsafe {
            (*self.buffer[head].get()).take()
        };

        let next_head = (head + 1) & (self.capacity - 1);
        self.head.store(next_head, Ordering::Release);

        value
    }

    pub fn is_empty(&self) -> bool {
        self.head.load(Ordering::Relaxed) == self.tail.load(Ordering::Relaxed)
    }

    pub fn len(&self) -> usize {
        let tail = self.tail.load(Ordering::Relaxed);
        let head = self.head.load(Ordering::Relaxed);
        if tail >= head {
            tail - head
        } else {
            self.capacity - head + tail
        }
    }
}

/// –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –º–∞—Ç—á–µ—Ä–∞
#[derive(Debug, Clone)]
pub enum MatcherMessage {
    NewOrder {
        id: u64,
        price: u64,
        quantity: u64,
        side: u8, // 0 = Bid, 1 = Ask
        symbol_id: u16,
    },
    CancelOrder {
        id: u64,
        symbol_id: u16,
    },
    Shutdown,
}

fn main() {
    let queue: SpscQueue<MatcherMessage> = SpscQueue::with_capacity(1024);

    // –°–∏–º—É–ª—è—Ü–∏—è producer
    for i in 0..10 {
        let msg = MatcherMessage::NewOrder {
            id: i,
            price: 50000 + i * 10,
            quantity: 100,
            side: (i % 2) as u8,
            symbol_id: 1,
        };

        match queue.try_push(msg) {
            Ok(()) => println!("Pushed order {}", i),
            Err(_) => println!("Queue full!"),
        }
    }

    println!("\nQueue length: {}", queue.len());

    // –°–∏–º—É–ª—è—Ü–∏—è consumer
    while let Some(msg) = queue.try_pop() {
        println!("Received: {:?}", msg);
    }

    println!("Queue empty: {}", queue.is_empty());
}
```

## –ß–∞—Å—Ç—å 5: –ü–æ–ª–Ω—ã–π –º–∞—Ç—á–µ—Ä —Å –±–µ–Ω—á–º–∞—Ä–∫–∏–Ω–≥–æ–º

```rust
use std::collections::BTreeMap;
use std::collections::VecDeque;
use std::cmp::Reverse;
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Side { Bid, Ask }

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OrderType { Limit, Market }

#[derive(Debug, Clone)]
pub struct Order {
    pub id: u64,
    pub price: u64,
    pub quantity: u64,
    pub filled: u64,
    pub timestamp: u64,
    pub side: Side,
}

impl Order {
    pub fn new(id: u64, price: u64, quantity: u64, side: Side, timestamp: u64) -> Self {
        Order { id, price, quantity, filled: 0, timestamp, side }
    }

    #[inline]
    pub fn remaining(&self) -> u64 { self.quantity - self.filled }
}

#[derive(Debug, Clone, Copy)]
pub struct Fill {
    pub maker_id: u64,
    pub taker_id: u64,
    pub price: u64,
    pub quantity: u64,
}

pub struct PriceLevel {
    pub price: u64,
    pub total_qty: u64,
    orders: VecDeque<Order>,
}

impl PriceLevel {
    pub fn new(price: u64) -> Self {
        PriceLevel { price, total_qty: 0, orders: VecDeque::with_capacity(64) }
    }

    pub fn add(&mut self, order: Order) {
        self.total_qty += order.remaining();
        self.orders.push_back(order);
    }

    pub fn front_mut(&mut self) -> Option<&mut Order> { self.orders.front_mut() }
    pub fn pop_front(&mut self) -> Option<Order> { self.orders.pop_front() }
    pub fn is_empty(&self) -> bool { self.orders.is_empty() }
}

/// –í—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –º–∞—Ç—á–µ—Ä
pub struct Matcher {
    bids: BTreeMap<Reverse<u64>, PriceLevel>,
    asks: BTreeMap<u64, PriceLevel>,
    fills: Vec<Fill>,

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    orders_processed: u64,
    total_fills: u64,
    total_volume: u64,
}

impl Matcher {
    pub fn new() -> Self {
        Matcher {
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            fills: Vec::with_capacity(1024),
            orders_processed: 0,
            total_fills: 0,
            total_volume: 0,
        }
    }

    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
    #[inline]
    pub fn process_order(&mut self, mut order: Order) -> &[Fill] {
        self.fills.clear();
        self.orders_processed += 1;

        match order.side {
            Side::Bid => self.match_bid(&mut order),
            Side::Ask => self.match_ask(&mut order),
        }

        &self.fills
    }

    #[inline]
    fn match_bid(&mut self, order: &mut Order) {
        // –ú–∞—Ç—á–∏–Ω–≥ —Å asks
        while order.remaining() > 0 {
            let Some(mut entry) = self.asks.first_entry() else { break };
            if *entry.key() > order.price { break; }

            let ask_price = *entry.key();
            let level = entry.get_mut();

            while order.remaining() > 0 && !level.is_empty() {
                let maker = level.front_mut().unwrap();
                let fill_qty = order.remaining().min(maker.remaining());
                let maker_id = maker.id;
                let maker_price = maker.price;

                maker.filled += fill_qty;
                order.filled += fill_qty;

                let maker_done = maker.remaining() == 0;

                self.fills.push(Fill {
                    maker_id,
                    taker_id: order.id,
                    price: maker_price,
                    quantity: fill_qty,
                });

                level.total_qty -= fill_qty;
                self.total_fills += 1;
                self.total_volume += fill_qty;

                if maker_done {
                    level.pop_front();
                }
            }

            if level.is_empty() {
                self.asks.remove(&ask_price);
            }
        }

        // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞—Ç–æ–∫
        if order.remaining() > 0 {
            self.bids
                .entry(Reverse(order.price))
                .or_insert_with(|| PriceLevel::new(order.price))
                .add(order.clone());
        }
    }

    #[inline]
    fn match_ask(&mut self, order: &mut Order) {
        // –ú–∞—Ç—á–∏–Ω–≥ —Å bids
        while order.remaining() > 0 {
            let Some(mut entry) = self.bids.first_entry() else { break };
            if entry.key().0 < order.price { break; }

            let bid_price = entry.key().0;
            let level = entry.get_mut();

            while order.remaining() > 0 && !level.is_empty() {
                let maker = level.front_mut().unwrap();
                let fill_qty = order.remaining().min(maker.remaining());
                let maker_id = maker.id;
                let maker_price = maker.price;

                maker.filled += fill_qty;
                order.filled += fill_qty;

                let maker_done = maker.remaining() == 0;

                self.fills.push(Fill {
                    maker_id,
                    taker_id: order.id,
                    price: maker_price,
                    quantity: fill_qty,
                });

                level.total_qty -= fill_qty;
                self.total_fills += 1;
                self.total_volume += fill_qty;

                if maker_done {
                    level.pop_front();
                }
            }

            if level.is_empty() {
                self.bids.remove(&Reverse(bid_price));
            }
        }

        // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞—Ç–æ–∫
        if order.remaining() > 0 {
            self.asks
                .entry(order.price)
                .or_insert_with(|| PriceLevel::new(order.price))
                .add(order.clone());
        }
    }

    pub fn best_bid(&self) -> Option<u64> {
        self.bids.keys().next().map(|r| r.0)
    }

    pub fn best_ask(&self) -> Option<u64> {
        self.asks.keys().next().copied()
    }

    pub fn stats(&self) -> MatcherStats {
        MatcherStats {
            orders_processed: self.orders_processed,
            total_fills: self.total_fills,
            total_volume: self.total_volume,
            bid_levels: self.bids.len(),
            ask_levels: self.asks.len(),
        }
    }
}

#[derive(Debug)]
pub struct MatcherStats {
    pub orders_processed: u64,
    pub total_fills: u64,
    pub total_volume: u64,
    pub bid_levels: usize,
    pub ask_levels: usize,
}

fn main() {
    let mut matcher = Matcher::new();

    println!("=== High-Performance Matcher Benchmark ===\n");

    // –ü—Ä–æ–≥—Ä–µ–≤
    for i in 0..1000 {
        let side = if i % 2 == 0 { Side::Bid } else { Side::Ask };
        let price = 50000 + (i % 100) * 10;
        let order = Order::new(i, price, 100, side, i);
        matcher.process_order(order);
    }

    // –ë–µ–Ω—á–º–∞—Ä–∫
    let num_orders = 100_000u64;
    let start = Instant::now();

    for i in 0..num_orders {
        let side = if i % 2 == 0 { Side::Bid } else { Side::Ask };
        // –°–æ–∑–¥–∞—ë–º –æ—Ä–¥–µ—Ä–∞ –æ–∫–æ–ª–æ mid-price –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –º–∞—Ç—á–∏–Ω–≥–∞
        let price = 50000 + ((i as i64 % 20) - 10) as u64 * 5;
        let order = Order::new(i + 1000, price, 10 + (i % 50), side, i);
        matcher.process_order(order);
    }

    let elapsed = start.elapsed();
    let orders_per_sec = num_orders as f64 / elapsed.as_secs_f64();
    let latency_ns = elapsed.as_nanos() as f64 / num_orders as f64;

    println!("Processed {} orders in {:?}", num_orders, elapsed);
    println!("Throughput: {:.0} orders/sec", orders_per_sec);
    println!("Average latency: {:.0} ns/order", latency_ns);
    println!("\nMatcher stats: {:?}", matcher.stats());
    println!("Best bid: {:?}, Best ask: {:?}", matcher.best_bid(), matcher.best_ask());
}
```

## –ß–∞—Å—Ç—å 6: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –º–∏—Ä–∞

### –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ª—É—á—à–∏—Ö —Ü–µ–Ω

```rust
use std::sync::atomic::{AtomicU64, Ordering};

/// –ê—Ç–æ–º–∞—Ä–Ω—ã–π –∫–µ—à –ª—É—á—à–∏—Ö —Ü–µ–Ω
pub struct BestPriceCache {
    best_bid: AtomicU64,
    best_ask: AtomicU64,
}

impl BestPriceCache {
    pub const NO_PRICE: u64 = u64::MAX;

    pub fn new() -> Self {
        BestPriceCache {
            best_bid: AtomicU64::new(Self::NO_PRICE),
            best_ask: AtomicU64::new(Self::NO_PRICE),
        }
    }

    #[inline]
    pub fn update_bid(&self, price: u64) {
        self.best_bid.store(price, Ordering::Release);
    }

    #[inline]
    pub fn update_ask(&self, price: u64) {
        self.best_ask.store(price, Ordering::Release);
    }

    #[inline]
    pub fn get_bid(&self) -> Option<u64> {
        let bid = self.best_bid.load(Ordering::Acquire);
        if bid == Self::NO_PRICE { None } else { Some(bid) }
    }

    #[inline]
    pub fn get_ask(&self) -> Option<u64> {
        let ask = self.best_ask.load(Ordering::Acquire);
        if ask == Self::NO_PRICE { None } else { Some(ask) }
    }

    #[inline]
    pub fn spread(&self) -> Option<u64> {
        match (self.get_bid(), self.get_ask()) {
            (Some(bid), Some(ask)) if ask > bid => Some(ask - bid),
            _ => None,
        }
    }
}

fn main() {
    let cache = BestPriceCache::new();

    cache.update_bid(50000);
    cache.update_ask(50010);

    println!("Best bid: {:?}", cache.get_bid());
    println!("Best ask: {:?}", cache.get_ask());
    println!("Spread: {:?}", cache.spread());
}
```

### –ü—Ä–µ–¥–∞–ª–ª–æ–∫–∞—Ü–∏—è –∏ Arena Allocator

```rust
/// –ü—Ä–æ—Å—Ç–æ–π arena-–∞–ª–ª–æ–∫–∞—Ç–æ—Ä –¥–ª—è fills
pub struct FillArena {
    buffer: Vec<Fill>,
    cursor: usize,
}

#[derive(Debug, Clone, Copy, Default)]
pub struct Fill {
    pub maker_id: u64,
    pub taker_id: u64,
    pub price: u64,
    pub quantity: u64,
}

impl FillArena {
    pub fn with_capacity(capacity: usize) -> Self {
        FillArena {
            buffer: vec![Fill::default(); capacity],
            cursor: 0,
        }
    }

    /// –°–±—Ä–æ—Å –∞—Ä–µ–Ω—ã –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    #[inline]
    pub fn reset(&mut self) {
        self.cursor = 0;
    }

    /// –ê–ª–ª–æ–∫–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ fill –±–µ–∑ heap allocation
    #[inline]
    pub fn alloc(&mut self, fill: Fill) -> Option<&Fill> {
        if self.cursor >= self.buffer.len() {
            return None;
        }
        self.buffer[self.cursor] = fill;
        let result = &self.buffer[self.cursor];
        self.cursor += 1;
        Some(result)
    }

    /// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ fills
    pub fn fills(&self) -> &[Fill] {
        &self.buffer[..self.cursor]
    }

    pub fn len(&self) -> usize {
        self.cursor
    }
}

fn main() {
    let mut arena = FillArena::with_capacity(1000);

    // –ê–ª–ª–æ–∫–∞—Ü–∏—è –±–µ–∑ heap
    for i in 0..10 {
        arena.alloc(Fill {
            maker_id: i,
            taker_id: i + 100,
            price: 50000,
            quantity: 100,
        });
    }

    println!("Fills count: {}", arena.len());
    for fill in arena.fills() {
        println!("  {:?}", fill);
    }

    // –°–±—Ä–æ—Å –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    arena.reset();
    println!("After reset: {}", arena.len());
}
```

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 1: –û—Ç–º–µ–Ω–∞ –æ—Ä–¥–µ—Ä–æ–≤

–î–æ–±–∞–≤—å—Ç–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –æ—Ç–º–µ–Ω—ã –æ—Ä–¥–µ—Ä–æ–≤ –≤ –º–∞—Ç—á–µ—Ä:

```rust
impl Matcher {
    /// –û—Ç–º–µ–Ω–∏—Ç—å –æ—Ä–¥–µ—Ä –ø–æ ID
    pub fn cancel_order(&mut self, order_id: u64) -> Option<Order> {
        // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
        // –ü–æ–¥—Å–∫–∞–∑–∫–∞: –Ω—É–∂–Ω–æ –∏—Å–∫–∞—Ç—å –≤ –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω–∞—Ö –∫–Ω–∏–≥–∏
        // –∏ —É–¥–∞–ª—è—Ç—å –æ—Ä–¥–µ—Ä –∏–∑ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è —Ü–µ–Ω—ã
        todo!()
    }
}
```

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 2: Fill-or-Kill –æ—Ä–¥–µ—Ä–∞

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –æ–±—Ä–∞–±–æ—Ç–∫—É FoK –æ—Ä–¥–µ—Ä–æ–≤ (–ø–æ–ª–Ω–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–ª–∏ –æ—Ç–º–µ–Ω–∞):

```rust
impl Matcher {
    /// FoK –æ—Ä–¥–µ—Ä ‚Äî –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–ª–∏ –æ—Ç–º–µ–Ω—è–µ—Ç—Å—è
    pub fn process_fok_order(&mut self, order: Order) -> Result<Vec<Fill>, &'static str> {
        // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
        // 1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
        // 2. –ï—Å–ª–∏ –¥–∞ ‚Äî –∏—Å–ø–æ–ª–Ω–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é
        // 3. –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É
        todo!()
    }
}
```

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 3: Immediate-or-Cancel –æ—Ä–¥–µ—Ä–∞

–†–µ–∞–ª–∏–∑—É–π—Ç–µ IoC –æ—Ä–¥–µ—Ä–∞ (–Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ —á–∞—Å—Ç–∏—á–Ω–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ):

```rust
impl Matcher {
    /// IoC –æ—Ä–¥–µ—Ä ‚Äî –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å–∫–æ–ª—å–∫–æ –≤–æ–∑–º–æ–∂–Ω–æ, –æ—Å—Ç–∞—Ç–æ–∫ –æ—Ç–º–µ–Ω—è–µ—Ç—Å—è
    pub fn process_ioc_order(&mut self, order: Order) -> Vec<Fill> {
        // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
        // 1. –ú–∞—Ç—á–∏—Ç—å –∫–∞–∫ –æ–±—ã—á–Ω—ã–π –æ—Ä–¥–µ—Ä
        // 2. –ù–ï –¥–æ–±–∞–≤–ª—è—Ç—å –æ—Å—Ç–∞—Ç–æ–∫ –≤ –∫–Ω–∏–≥—É
        todo!()
    }
}
```

### –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 4: –ú–µ—Ç—Ä–∏–∫–∏ –ª–∞—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏

–î–æ–±–∞–≤—å—Ç–µ —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –ª–∞—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏:

```rust
pub struct LatencyStats {
    pub min_ns: u64,
    pub max_ns: u64,
    pub avg_ns: f64,
    pub p50_ns: u64,
    pub p99_ns: u64,
    pub p999_ns: u64,
}

impl Matcher {
    /// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ª–∞—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
    pub fn latency_stats(&self) -> LatencyStats {
        // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
        todo!()
    }
}
```

## –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ

### 1. –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –º–∞—Ç—á–µ—Ä

–°–æ–∑–¥–∞–π—Ç–µ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—É—é –≤–µ—Ä—Å–∏—é –º–∞—Ç—á–µ—Ä–∞:

```rust
/// –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –º–∞—Ç—á–µ—Ä —Å —à–∞—Ä–¥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø–æ —Å–∏–º–≤–æ–ª–∞–º
pub struct ShardedMatcher {
    shards: Vec<std::sync::Mutex<Matcher>>,
    shard_count: usize,
}

impl ShardedMatcher {
    pub fn new(shard_count: usize) -> Self { todo!() }

    /// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —à–∞—Ä–¥–∞ –ø–æ symbol_id
    fn get_shard(&self, symbol_id: u16) -> usize { todo!() }

    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ä–¥–µ—Ä–∞ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º —à–∞—Ä–¥–µ
    pub fn process_order(&self, order: Order, symbol_id: u16) -> Vec<Fill> { todo!() }
}
```

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- –®–∞—Ä–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ —Å–∏–º–≤–æ–ª–∞–º –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
- Lock-free –æ—á–µ—Ä–µ–¥—å –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö –æ—Ä–¥–µ—Ä–æ–≤
- –ê—Ç–æ–º–∞—Ä–Ω—ã–µ —Å—á—ë—Ç—á–∏–∫–∏ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
- –ë–µ–Ω—á–º–∞—Ä–∫ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### 2. –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ

–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º—É —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è:

```rust
/// –°–Ω—ç–ø—à–æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è –º–∞—Ç—á–µ—Ä–∞
pub struct MatcherSnapshot {
    pub timestamp: u64,
    pub orders: Vec<Order>,
    pub sequence_number: u64,
}

impl Matcher {
    /// –°–æ–∑–¥–∞—Ç—å —Å–Ω—ç–ø—à–æ—Ç —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    pub fn snapshot(&self) -> MatcherSnapshot { todo!() }

    /// –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ —Å–Ω—ç–ø—à–æ—Ç–∞
    pub fn restore(snapshot: MatcherSnapshot) -> Self { todo!() }

    /// –ñ—É—Ä–Ω–∞–ª –æ–ø–µ—Ä–∞—Ü–∏–π –¥–ª—è replay
    pub fn operation_log(&self) -> Vec<MatcherOperation> { todo!() }
}
```

### 3. –°–∏–º—É–ª—è—Ü–∏—è —Ä—ã–Ω–∫–∞

–°–æ–∑–¥–∞–π—Ç–µ —Å–∏–º—É–ª—è—Ç–æ—Ä —Ä—ã–Ω–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:

```rust
/// –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
pub struct MarketSimulator {
    pub symbol_id: u16,
    pub base_price: u64,
    pub volatility: f64,
    pub order_rate: f64,  // –æ—Ä–¥–µ—Ä–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
}

impl MarketSimulator {
    /// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
    pub fn generate_order(&mut self) -> Order { todo!() }

    /// –°–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π —Å–µ—Å—Å–∏–∏
    pub fn simulate(&mut self, matcher: &mut Matcher, duration_secs: u64) -> SimulationResult {
        todo!()
    }
}

pub struct SimulationResult {
    pub total_orders: u64,
    pub total_fills: u64,
    pub total_volume: u64,
    pub final_price: u64,
    pub price_volatility: f64,
    pub avg_latency_ns: f64,
}
```

### 4. –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ç–∏–ø—ã –æ—Ä–¥–µ—Ä–æ–≤

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–∏–ø—ã –æ—Ä–¥–µ—Ä–æ–≤:

```rust
#[derive(Debug, Clone)]
pub enum AdvancedOrder {
    /// Stop-loss –æ—Ä–¥–µ—Ä
    StopLoss {
        order: Order,
        trigger_price: u64,
    },
    /// Take-profit –æ—Ä–¥–µ—Ä
    TakeProfit {
        order: Order,
        trigger_price: u64,
    },
    /// Trailing stop
    TrailingStop {
        order: Order,
        trail_amount: u64,
        highest_price: u64,
    },
    /// Iceberg –æ—Ä–¥–µ—Ä (—Å–∫—Ä—ã—Ç—ã–π –æ–±—ä—ë–º)
    Iceberg {
        order: Order,
        visible_quantity: u64,
        total_quantity: u64,
    },
}

impl Matcher {
    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö —Ç–∏–ø–æ–≤ –æ—Ä–¥–µ—Ä–æ–≤
    pub fn process_advanced_order(&mut self, order: AdvancedOrder) -> Vec<Fill> {
        todo!()
    }

    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤ –ø–æ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω–µ
    pub fn check_triggers(&mut self, current_price: u64) -> Vec<Fill> {
        todo!()
    }
}
```

## –ß—Ç–æ –º—ã –∏–∑—É—á–∏–ª–∏

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ |
|-----------|------------|
| **Zero-copy** | –ü–µ—Ä–µ–¥–∞—á–∞ –æ—Ä–¥–µ—Ä–æ–≤ –±–µ–∑ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è |
| **–ü—Ä–µ–¥–∞–ª–ª–æ–∫–∞—Ü–∏—è** | –ü—É–ª—ã –ø–∞–º—è—Ç–∏ –¥–ª—è –æ—Ä–¥–µ—Ä–æ–≤ –∏ fills |
| **Lock-free —Å—Ç—Ä—É–∫—Ç—É—Ä—ã** | SPSC –æ—á–µ—Ä–µ–¥–∏ –¥–ª—è –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç–∏ |
| **–ö—ç—à-–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è** | –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä –ø–æ–¥ –∫—ç—à-–ª–∏–Ω–∏–∏ |
| **BTreeMap** | –°–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π —Ü–µ–Ω |
| **–ê—Ç–æ–º–∞—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏** | –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ª—É—á—à–∏—Ö —Ü–µ–Ω |
| **Arena allocator** | –ò–∑–±–µ–∂–∞–Ω–∏–µ heap allocations |
| **–ë–µ–Ω—á–º–∞—Ä–∫–∏–Ω–≥** | –ò–∑–º–µ—Ä–µ–Ω–∏–µ –ø—Ä–æ–ø—É—Å–∫–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ |

## –ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

| –ú–µ—Ç—Ä–∏–∫–∞ | –¢–∏–ø–∏—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ | –¶–µ–ª—å |
|---------|------------------|------|
| –õ–∞—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å | 100-500 –Ω—Å | < 1 –º–∫—Å |
| –ü—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å | 1-5 –º–ª–Ω –æ—Ä–¥/—Å | > 1 –º–ª–Ω |
| –ê–ª–ª–æ–∫–∞—Ü–∏–∏ | 0 –Ω–∞ –≥–æ—Ä—è—á–µ–º –ø—É—Ç–∏ | 0 |
| Cache misses | –ú–∏–Ω–∏–º—É–º | < 1% |

## –ù–∞–≤–∏–≥–∞—Ü–∏—è

[‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å](../326-async-vs-threading/ru.md) | [–°–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å ‚Üí](../335-*/ru.md)
