# –î–µ–Ω—å 353: –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ

## –ê–Ω–∞–ª–æ–≥–∏—è –∏–∑ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞

–ü—Ä–µ–¥—Å—Ç–∞–≤—å, —á—Ç–æ —É —Ç–µ–±—è –µ—Å—Ç—å —Ç–æ—Ä–≥–æ–≤—ã–π —Ä–æ–±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–±–æ—Ç–∞–µ—Ç 24/7 –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º —Ä—ã–Ω–∫–µ. –û–Ω –∫–∞–∫ –æ–ø—ã—Ç–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω –ø–æ—Å—Ç–æ—è–Ω–Ω–æ —Å–ª–µ–¥–∏—Ç—å –∑–∞:

**–ó–¥–æ—Ä–æ–≤—å–µ —Å–∏—Å—Ç–µ–º—ã = –ó–¥–æ—Ä–æ–≤—å–µ —Ç—Ä–µ–π–¥–µ—Ä–∞:**
- –ü—É–ª—å—Å (heartbeat) ‚Äî —Å–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –æ—Ç–≤–µ—á–∞–µ—Ç
- –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ (CPU/Memory) ‚Äî –Ω–∞–≥—Ä—É–∑–∫–∞ –≤ –Ω–æ—Ä–º–µ
- –î–∞–≤–ª–µ–Ω–∏–µ (latency) ‚Äî –∑–∞–¥–µ—Ä–∂–∫–∏ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ

**–¢–æ—Ä–≥–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ = –ü–æ–∫–∞–∑–∞—Ç–µ–ª–∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:**
- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–¥–µ–ª–æ–∫ –≤ –º–∏–Ω—É—Ç—É
- –°—Ä–µ–¥–Ω—è—è –ø—Ä–∏–±—ã–ª—å –Ω–∞ —Å–¥–µ–ª–∫—É
- –í—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–æ–≤
- –ü—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ (slippage)

**–ê–ª–µ—Ä—Ç—ã = –°–∏–≥–Ω–∞–ª—ã —Ç—Ä–µ–≤–æ–≥–∏:**
- –ü–æ—Ç–µ—Ä—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –±–∏—Ä–∂–µ–π ‚Äî –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ–ø–æ–≤–µ—Å—Ç–∏—Ç—å
- –ê–Ω–æ–º–∞–ª—å–Ω—ã–µ –ø–æ—Ç–µ—Ä–∏ ‚Äî –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ—Ä–≥–æ–≤–ª—é
- –ò—Å—á–µ—Ä–ø–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏ ‚Äî –ø—Ä–µ–¥—É–ø—Ä–µ–¥–∏—Ç—å –∑–∞—Ä–∞–Ω–µ–µ

| –ê—Å–ø–µ–∫—Ç | –ë–µ–∑ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ | –° –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º |
|--------|-----------------|----------------|
| **–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º** | –ö–æ–≥–¥–∞ –¥–µ–Ω—å–≥–∏ –ø–æ—Ç–µ—Ä—è–Ω—ã | –ó–∞—Ä–∞–Ω–µ–µ |
| **–í—Ä–µ–º—è —Ä–µ–∞–∫—Ü–∏–∏** | –ß–∞—Å—ã/–¥–Ω–∏ | –°–µ–∫—É–Ω–¥—ã/–º–∏–Ω—É—Ç—ã |
| **–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞** | –ì–∞–¥–∞–Ω–∏–µ | –¢–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ |
| **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è** | –í—Å–ª–µ–ø—É—é | –ù–∞ –æ—Å–Ω–æ–≤–µ –º–µ—Ç—Ä–∏–∫ |

## –û—Å–Ω–æ–≤—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≤ Rust

### –¢–∏–ø—ã –º–µ—Ç—Ä–∏–∫

```rust
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};

/// –¢–∏–ø—ã –º–µ—Ç—Ä–∏–∫ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
#[derive(Debug)]
pub struct TradingMetrics {
    // –°—á—ë—Ç—á–∏–∫–∏ (Counter) ‚Äî —Ç–æ–ª—å–∫–æ —É–≤–µ–ª–∏—á–∏–≤–∞—é—Ç—Å—è
    pub orders_placed: AtomicU64,
    pub orders_filled: AtomicU64,
    pub orders_cancelled: AtomicU64,
    pub orders_rejected: AtomicU64,

    // –ò–∑–º–µ—Ä–∏—Ç–µ–ª–∏ (Gauge) ‚Äî —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    pub open_positions: AtomicUsize,
    pub active_orders: AtomicUsize,
    pub available_balance_cents: AtomicU64,

    // –ì–∏—Å—Ç–æ–≥—Ä–∞–º–º—ã (Histogram) ‚Äî —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
    // –î–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è —Ö—Ä–∞–Ω–∏–º —Å—É–º–º—É –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
    pub order_latency_sum_us: AtomicU64,
    pub order_latency_count: AtomicU64,
}

impl TradingMetrics {
    pub fn new() -> Self {
        TradingMetrics {
            orders_placed: AtomicU64::new(0),
            orders_filled: AtomicU64::new(0),
            orders_cancelled: AtomicU64::new(0),
            orders_rejected: AtomicU64::new(0),
            open_positions: AtomicUsize::new(0),
            active_orders: AtomicUsize::new(0),
            available_balance_cents: AtomicU64::new(0),
            order_latency_sum_us: AtomicU64::new(0),
            order_latency_count: AtomicU64::new(0),
        }
    }

    pub fn record_order_placed(&self) {
        self.orders_placed.fetch_add(1, Ordering::Relaxed);
        self.active_orders.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_order_filled(&self, latency: Duration) {
        self.orders_filled.fetch_add(1, Ordering::Relaxed);
        self.active_orders.fetch_sub(1, Ordering::Relaxed);

        let latency_us = latency.as_micros() as u64;
        self.order_latency_sum_us.fetch_add(latency_us, Ordering::Relaxed);
        self.order_latency_count.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_order_cancelled(&self) {
        self.orders_cancelled.fetch_add(1, Ordering::Relaxed);
        self.active_orders.fetch_sub(1, Ordering::Relaxed);
    }

    pub fn record_order_rejected(&self) {
        self.orders_rejected.fetch_add(1, Ordering::Relaxed);
    }

    pub fn set_open_positions(&self, count: usize) {
        self.open_positions.store(count, Ordering::Relaxed);
    }

    pub fn set_balance(&self, balance_cents: u64) {
        self.available_balance_cents.store(balance_cents, Ordering::Relaxed);
    }

    pub fn average_order_latency(&self) -> Option<Duration> {
        let count = self.order_latency_count.load(Ordering::Relaxed);
        if count == 0 {
            return None;
        }
        let sum = self.order_latency_sum_us.load(Ordering::Relaxed);
        Some(Duration::from_micros(sum / count))
    }

    pub fn report(&self) {
        println!("=== Trading Metrics ===");
        println!("Orders: placed={}, filled={}, cancelled={}, rejected={}",
            self.orders_placed.load(Ordering::Relaxed),
            self.orders_filled.load(Ordering::Relaxed),
            self.orders_cancelled.load(Ordering::Relaxed),
            self.orders_rejected.load(Ordering::Relaxed));
        println!("Active orders: {}", self.active_orders.load(Ordering::Relaxed));
        println!("Open positions: {}", self.open_positions.load(Ordering::Relaxed));
        println!("Balance: ${:.2}",
            self.available_balance_cents.load(Ordering::Relaxed) as f64 / 100.0);
        if let Some(latency) = self.average_order_latency() {
            println!("Avg order latency: {:?}", latency);
        }
    }
}

fn main() {
    let metrics = Arc::new(TradingMetrics::new());
    metrics.set_balance(100_000_00); // $100,000

    // –°–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    for i in 0..100 {
        metrics.record_order_placed();

        // 90% –æ—Ä–¥–µ—Ä–æ–≤ –∏—Å–ø–æ–ª–Ω—è—é—Ç—Å—è
        if i % 10 != 0 {
            let latency = Duration::from_millis(50 + (i % 30) as u64);
            metrics.record_order_filled(latency);
        } else {
            metrics.record_order_cancelled();
        }
    }

    metrics.set_open_positions(5);
    metrics.report();
}
```

### Health Checks (–ü—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è)

```rust
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use std::collections::HashMap;

/// –°—Ç–∞—Ç—É—Å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
#[derive(Debug, Clone, PartialEq)]
pub enum HealthStatus {
    Healthy,
    Degraded(String),
    Unhealthy(String),
}

/// –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è
#[derive(Debug, Clone)]
pub struct HealthCheck {
    pub name: String,
    pub status: HealthStatus,
    pub last_check: u64,  // Unix timestamp
    pub latency_ms: u64,
}

/// –ú–µ–Ω–µ–¥–∂–µ—Ä –ø—Ä–æ–≤–µ—Ä–æ–∫ –∑–¥–æ—Ä–æ–≤—å—è
pub struct HealthManager {
    checks: HashMap<String, Box<dyn Fn() -> HealthCheck + Send + Sync>>,
}

impl HealthManager {
    pub fn new() -> Self {
        HealthManager {
            checks: HashMap::new(),
        }
    }

    pub fn register<F>(&mut self, name: &str, check: F)
    where
        F: Fn() -> HealthCheck + Send + Sync + 'static,
    {
        self.checks.insert(name.to_string(), Box::new(check));
    }

    pub fn check_all(&self) -> Vec<HealthCheck> {
        self.checks.values().map(|check| check()).collect()
    }

    pub fn is_healthy(&self) -> bool {
        self.check_all().iter().all(|c| matches!(c.status, HealthStatus::Healthy))
    }
}

/// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∏—Ä–∂–µ
struct ExchangeConnection {
    is_connected: AtomicBool,
    last_message_time: AtomicU64,
}

impl ExchangeConnection {
    fn new() -> Self {
        ExchangeConnection {
            is_connected: AtomicBool::new(true),
            last_message_time: AtomicU64::new(
                SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
            ),
        }
    }

    fn health_check(&self) -> HealthCheck {
        let start = Instant::now();
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        let is_connected = self.is_connected.load(Ordering::Relaxed);
        let last_msg = self.last_message_time.load(Ordering::Relaxed);
        let seconds_since_message = now.saturating_sub(last_msg);

        let status = if !is_connected {
            HealthStatus::Unhealthy("Disconnected from exchange".to_string())
        } else if seconds_since_message > 30 {
            HealthStatus::Unhealthy(format!("No data for {} seconds", seconds_since_message))
        } else if seconds_since_message > 10 {
            HealthStatus::Degraded(format!("Slow data: {} seconds since last update", seconds_since_message))
        } else {
            HealthStatus::Healthy
        };

        HealthCheck {
            name: "exchange_connection".to_string(),
            status,
            last_check: now,
            latency_ms: start.elapsed().as_millis() as u64,
        }
    }

    fn simulate_message(&self) {
        self.last_message_time.store(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            Ordering::Relaxed,
        );
    }

    fn disconnect(&self) {
        self.is_connected.store(false, Ordering::Relaxed);
    }
}

/// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–º—è—Ç–∏
fn memory_health_check() -> HealthCheck {
    let start = Instant::now();

    // –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ sys-info –∏–ª–∏ procfs
    // –ó–¥–µ—Å—å —Å–∏–º—É–ª—è—Ü–∏—è
    let used_mb = 512;
    let total_mb = 2048;
    let usage_percent = (used_mb * 100) / total_mb;

    let status = if usage_percent > 90 {
        HealthStatus::Unhealthy(format!("Memory critical: {}%", usage_percent))
    } else if usage_percent > 75 {
        HealthStatus::Degraded(format!("Memory high: {}%", usage_percent))
    } else {
        HealthStatus::Healthy
    };

    HealthCheck {
        name: "memory".to_string(),
        status,
        last_check: SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs(),
        latency_ms: start.elapsed().as_millis() as u64,
    }
}

fn main() {
    let exchange = Arc::new(ExchangeConnection::new());
    let exchange_clone = Arc::clone(&exchange);

    let mut health_manager = HealthManager::new();

    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
    health_manager.register("exchange", move || exchange_clone.health_check());
    health_manager.register("memory", memory_health_check);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ —Å–∏—Å—Ç–µ–º—ã
    println!("=== Health Check (–≤—Å–µ —Ö–æ—Ä–æ—à–æ) ===");
    for check in health_manager.check_all() {
        println!("{}: {:?} ({}ms)", check.name, check.status, check.latency_ms);
    }
    println!("System healthy: {}\n", health_manager.is_healthy());

    // –°–∏–º—É–ª—è—Ü–∏—è –ø—Ä–æ–±–ª–µ–º—ã
    exchange.disconnect();

    println!("=== Health Check (–ø–æ—Å–ª–µ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –±–∏—Ä–∂–∏) ===");
    for check in health_manager.check_all() {
        println!("{}: {:?} ({}ms)", check.name, check.status, check.latency_ms);
    }
    println!("System healthy: {}", health_manager.is_healthy());
}
```

## –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Prometheus

```rust
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Arc, RwLock};
use std::time::Instant;

/// –§–æ—Ä–º–∞—Ç –º–µ—Ç—Ä–∏–∫ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Å Prometheus
pub struct PrometheusRegistry {
    counters: RwLock<HashMap<String, AtomicU64>>,
    gauges: RwLock<HashMap<String, AtomicU64>>,
    labels: RwLock<HashMap<String, HashMap<String, String>>>,
}

impl PrometheusRegistry {
    pub fn new() -> Self {
        PrometheusRegistry {
            counters: RwLock::new(HashMap::new()),
            gauges: RwLock::new(HashMap::new()),
            labels: RwLock::new(HashMap::new()),
        }
    }

    pub fn counter(&self, name: &str) -> &AtomicU64 {
        let mut counters = self.counters.write().unwrap();
        if !counters.contains_key(name) {
            counters.insert(name.to_string(), AtomicU64::new(0));
        }
        // –ë–µ–∑–æ–ø–∞—Å–Ω–æ: –º—ã —Ç–æ–ª—å–∫–æ –¥–æ–±–∞–≤–ª—è–µ–º, –Ω–µ —É–¥–∞–ª—è–µ–º
        unsafe {
            let ptr = counters.get(name).unwrap() as *const AtomicU64;
            &*ptr
        }
    }

    pub fn inc_counter(&self, name: &str) {
        let counters = self.counters.read().unwrap();
        if let Some(counter) = counters.get(name) {
            counter.fetch_add(1, Ordering::Relaxed);
        } else {
            drop(counters);
            let mut counters = self.counters.write().unwrap();
            counters.entry(name.to_string())
                .or_insert_with(|| AtomicU64::new(0))
                .fetch_add(1, Ordering::Relaxed);
        }
    }

    pub fn set_gauge(&self, name: &str, value: u64) {
        let mut gauges = self.gauges.write().unwrap();
        gauges.entry(name.to_string())
            .or_insert_with(|| AtomicU64::new(0))
            .store(value, Ordering::Relaxed);
    }

    pub fn set_labels(&self, name: &str, labels: HashMap<String, String>) {
        let mut all_labels = self.labels.write().unwrap();
        all_labels.insert(name.to_string(), labels);
    }

    /// –≠–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ Prometheus
    pub fn export(&self) -> String {
        let mut output = String::new();

        // –≠–∫—Å–ø–æ—Ä—Ç —Å—á—ë—Ç—á–∏–∫–æ–≤
        let counters = self.counters.read().unwrap();
        let labels = self.labels.read().unwrap();

        for (name, value) in counters.iter() {
            let label_str = if let Some(l) = labels.get(name) {
                let pairs: Vec<String> = l.iter()
                    .map(|(k, v)| format!("{}=\"{}\"", k, v))
                    .collect();
                format!("{{{}}}", pairs.join(","))
            } else {
                String::new()
            };

            output.push_str(&format!(
                "# TYPE {} counter\n{}{} {}\n",
                name, name, label_str, value.load(Ordering::Relaxed)
            ));
        }

        // –≠–∫—Å–ø–æ—Ä—Ç gauges
        let gauges = self.gauges.read().unwrap();
        for (name, value) in gauges.iter() {
            let label_str = if let Some(l) = labels.get(name) {
                let pairs: Vec<String> = l.iter()
                    .map(|(k, v)| format!("{}=\"{}\"", k, v))
                    .collect();
                format!("{{{}}}", pairs.join(","))
            } else {
                String::new()
            };

            output.push_str(&format!(
                "# TYPE {} gauge\n{}{} {}\n",
                name, name, label_str, value.load(Ordering::Relaxed)
            ));
        }

        output
    }
}

/// –ú–µ—Ç—Ä–∏–∫–∏ —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –¥–ª—è Prometheus
struct TradingPrometheusMetrics {
    registry: Arc<PrometheusRegistry>,
}

impl TradingPrometheusMetrics {
    fn new() -> Self {
        let registry = Arc::new(PrometheusRegistry::new());

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç—Ä–∏–∫ —Å –ª–µ–π–±–ª–∞–º–∏
        let mut labels = HashMap::new();
        labels.insert("exchange".to_string(), "binance".to_string());
        labels.insert("symbol".to_string(), "BTCUSDT".to_string());
        registry.set_labels("trading_orders_total", labels);

        TradingPrometheusMetrics { registry }
    }

    fn record_order(&self, order_type: &str) {
        let metric_name = format!("trading_orders_{}", order_type);
        self.registry.inc_counter(&metric_name);
        self.registry.inc_counter("trading_orders_total");
    }

    fn set_position_size(&self, size: f64) {
        // –•—Ä–∞–Ω–∏–º –≤ —Å–æ—Ç—ã—Ö –¥–æ–ª—è—Ö –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏
        self.registry.set_gauge("trading_position_size", (size * 100.0) as u64);
    }

    fn set_pnl(&self, pnl: f64) {
        // –•—Ä–∞–Ω–∏–º P&L –≤ —Ü–µ–Ω—Ç–∞—Ö (–º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º, –ø–æ—ç—Ç–æ–º—É –¥–æ–±–∞–≤–ª—è–µ–º offset)
        let offset_pnl = ((pnl + 1_000_000.0) * 100.0) as u64;
        self.registry.set_gauge("trading_pnl_cents", offset_pnl);
    }

    fn export(&self) -> String {
        self.registry.export()
    }
}

fn main() {
    let metrics = TradingPrometheusMetrics::new();

    // –°–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏
    for _ in 0..50 {
        metrics.record_order("filled");
    }
    for _ in 0..10 {
        metrics.record_order("cancelled");
    }
    for _ in 0..5 {
        metrics.record_order("rejected");
    }

    metrics.set_position_size(1.5);
    metrics.set_pnl(2500.50);

    println!("=== Prometheus Export ===\n");
    println!("{}", metrics.export());
}
```

## –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞

```rust
use std::collections::HashMap;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};

/// –£—Ä–æ–≤–Ω–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
#[derive(Debug, Clone, Copy, PartialEq, Ord, PartialOrd, Eq)]
pub enum LogLevel {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Error = 3,
}

/// –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∑–∞–ø–∏—Å—å –ª–æ–≥–∞
#[derive(Debug)]
pub struct LogEntry {
    pub timestamp: u64,
    pub level: LogLevel,
    pub message: String,
    pub fields: HashMap<String, String>,
}

/// –ü—Ä–æ—Å—Ç–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ–≥–≥–µ—Ä
pub struct StructuredLogger {
    min_level: LogLevel,
    log_count: AtomicUsize,
}

impl StructuredLogger {
    pub fn new(min_level: LogLevel) -> Self {
        StructuredLogger {
            min_level,
            log_count: AtomicUsize::new(0),
        }
    }

    pub fn log(&self, level: LogLevel, message: &str, fields: HashMap<String, String>) {
        if level < self.min_level {
            return;
        }

        self.log_count.fetch_add(1, Ordering::Relaxed);

        let entry = LogEntry {
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_millis() as u64,
            level,
            message: message.to_string(),
            fields,
        };

        // –í—ã–≤–æ–¥ –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        println!("{}", self.format_json(&entry));
    }

    fn format_json(&self, entry: &LogEntry) -> String {
        let level_str = match entry.level {
            LogLevel::Debug => "DEBUG",
            LogLevel::Info => "INFO",
            LogLevel::Warn => "WARN",
            LogLevel::Error => "ERROR",
        };

        let fields_json: Vec<String> = entry.fields.iter()
            .map(|(k, v)| format!("\"{}\":\"{}\"", k, v))
            .collect();

        format!(
            "{{\"ts\":{},\"level\":\"{}\",\"msg\":\"{}\",{}}}",
            entry.timestamp,
            level_str,
            entry.message.replace("\"", "\\\""),
            fields_json.join(",")
        )
    }

    pub fn debug(&self, message: &str, fields: HashMap<String, String>) {
        self.log(LogLevel::Debug, message, fields);
    }

    pub fn info(&self, message: &str, fields: HashMap<String, String>) {
        self.log(LogLevel::Info, message, fields);
    }

    pub fn warn(&self, message: &str, fields: HashMap<String, String>) {
        self.log(LogLevel::Warn, message, fields);
    }

    pub fn error(&self, message: &str, fields: HashMap<String, String>) {
        self.log(LogLevel::Error, message, fields);
    }

    pub fn log_count(&self) -> usize {
        self.log_count.load(Ordering::Relaxed)
    }
}

/// –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª–µ–π
macro_rules! log_fields {
    ($($key:expr => $value:expr),* $(,)?) => {{
        let mut map = std::collections::HashMap::new();
        $(
            map.insert($key.to_string(), $value.to_string());
        )*
        map
    }};
}

/// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π
fn log_order_placed(logger: &StructuredLogger, order_id: &str, symbol: &str, side: &str, price: f64, qty: f64) {
    logger.info("Order placed", log_fields! {
        "order_id" => order_id,
        "symbol" => symbol,
        "side" => side,
        "price" => format!("{:.2}", price),
        "quantity" => format!("{:.4}", qty),
    });
}

fn log_order_filled(logger: &StructuredLogger, order_id: &str, fill_price: f64, latency_ms: u64) {
    logger.info("Order filled", log_fields! {
        "order_id" => order_id,
        "fill_price" => format!("{:.2}", fill_price),
        "latency_ms" => latency_ms,
    });
}

fn log_error(logger: &StructuredLogger, error: &str, order_id: &str) {
    logger.error("Order error", log_fields! {
        "error" => error,
        "order_id" => order_id,
    });
}

fn main() {
    let logger = StructuredLogger::new(LogLevel::Info);

    println!("=== Structured Trading Logs ===\n");

    // –°–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    log_order_placed(&logger, "ORD-001", "BTCUSDT", "BUY", 50000.0, 0.1);
    log_order_filled(&logger, "ORD-001", 50001.50, 45);

    log_order_placed(&logger, "ORD-002", "ETHUSDT", "SELL", 3000.0, 1.0);
    log_error(&logger, "Insufficient balance", "ORD-002");

    log_order_placed(&logger, "ORD-003", "BTCUSDT", "BUY", 49950.0, 0.05);
    log_order_filled(&logger, "ORD-003", 49951.00, 38);

    println!("\nTotal log entries: {}", logger.log_count());
}
```

## –ê–ª–µ—Ä—Ç–∏–Ω–≥ (–û–ø–æ–≤–µ—â–µ–Ω–∏—è)

```rust
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

/// –£—Ä–æ–≤–µ–Ω—å –≤–∞–∂–Ω–æ—Å—Ç–∏ –∞–ª–µ—Ä—Ç–∞
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AlertSeverity {
    Info,
    Warning,
    Critical,
}

/// –ê–ª–µ—Ä—Ç
#[derive(Debug, Clone)]
pub struct Alert {
    pub name: String,
    pub severity: AlertSeverity,
    pub message: String,
    pub timestamp: Instant,
}

/// –ü—Ä–∞–≤–∏–ª–æ –∞–ª–µ—Ä—Ç–∏–Ω–≥–∞
pub struct AlertRule {
    pub name: String,
    pub severity: AlertSeverity,
    pub condition: Box<dyn Fn() -> Option<String> + Send + Sync>,
    pub cooldown: Duration,
    pub last_fired: RwLock<Option<Instant>>,
}

impl AlertRule {
    pub fn new<F>(name: &str, severity: AlertSeverity, cooldown: Duration, condition: F) -> Self
    where
        F: Fn() -> Option<String> + Send + Sync + 'static,
    {
        AlertRule {
            name: name.to_string(),
            severity,
            condition: Box::new(condition),
            cooldown,
            last_fired: RwLock::new(None),
        }
    }

    pub fn check(&self) -> Option<Alert> {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º cooldown
        if let Some(last) = *self.last_fired.read().unwrap() {
            if last.elapsed() < self.cooldown {
                return None;
            }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏–µ
        if let Some(message) = (self.condition)() {
            *self.last_fired.write().unwrap() = Some(Instant::now());
            return Some(Alert {
                name: self.name.clone(),
                severity: self.severity,
                message,
                timestamp: Instant::now(),
            });
        }

        None
    }
}

/// –ú–µ–Ω–µ–¥–∂–µ—Ä –∞–ª–µ—Ä—Ç–æ–≤
pub struct AlertManager {
    rules: Vec<Arc<AlertRule>>,
    alerts_fired: AtomicU64,
    is_silenced: AtomicBool,
}

impl AlertManager {
    pub fn new() -> Self {
        AlertManager {
            rules: Vec::new(),
            alerts_fired: AtomicU64::new(0),
            is_silenced: AtomicBool::new(false),
        }
    }

    pub fn add_rule(&mut self, rule: AlertRule) {
        self.rules.push(Arc::new(rule));
    }

    pub fn check_all(&self) -> Vec<Alert> {
        if self.is_silenced.load(Ordering::Relaxed) {
            return Vec::new();
        }

        let mut alerts = Vec::new();
        for rule in &self.rules {
            if let Some(alert) = rule.check() {
                self.alerts_fired.fetch_add(1, Ordering::Relaxed);
                self.notify(&alert);
                alerts.push(alert);
            }
        }
        alerts
    }

    fn notify(&self, alert: &Alert) {
        let severity_str = match alert.severity {
            AlertSeverity::Info => "INFO",
            AlertSeverity::Warning => "WARNING",
            AlertSeverity::Critical => "CRITICAL",
        };

        println!("[ALERT][{}] {}: {}", severity_str, alert.name, alert.message);

        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ Slack, PagerDuty, –∏ —Ç.–¥.
    }

    pub fn silence(&self) {
        self.is_silenced.store(true, Ordering::Relaxed);
    }

    pub fn unsilence(&self) {
        self.is_silenced.store(false, Ordering::Relaxed);
    }
}

/// –¢–æ—Ä–≥–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –∞–ª–µ—Ä—Ç–∏–Ω–≥–∞
struct TradingState {
    pnl_cents: AtomicU64,       // –°–º–µ—â—ë–Ω–Ω—ã–π P&L (+ 1_000_000_00 –¥–ª—è –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö)
    position_size: AtomicU64,   // –í —Å–æ—Ç—ã—Ö –¥–æ–ª—è—Ö
    consecutive_losses: AtomicU64,
    last_exchange_heartbeat: AtomicU64,
}

impl TradingState {
    fn new() -> Self {
        TradingState {
            pnl_cents: AtomicU64::new(1_000_000_00), // 0 P&L
            position_size: AtomicU64::new(0),
            consecutive_losses: AtomicU64::new(0),
            last_exchange_heartbeat: AtomicU64::new(0),
        }
    }

    fn set_pnl(&self, pnl: f64) {
        let cents = ((pnl + 1_000_000.0) * 100.0) as u64;
        self.pnl_cents.store(cents, Ordering::Relaxed);
    }

    fn get_pnl(&self) -> f64 {
        let cents = self.pnl_cents.load(Ordering::Relaxed);
        (cents as f64 / 100.0) - 1_000_000.0
    }

    fn set_position(&self, size: f64) {
        self.position_size.store((size * 100.0) as u64, Ordering::Relaxed);
    }

    fn get_position(&self) -> f64 {
        self.position_size.load(Ordering::Relaxed) as f64 / 100.0
    }

    fn add_loss(&self) {
        self.consecutive_losses.fetch_add(1, Ordering::Relaxed);
    }

    fn reset_losses(&self) {
        self.consecutive_losses.store(0, Ordering::Relaxed);
    }

    fn heartbeat(&self) {
        self.last_exchange_heartbeat.store(
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            Ordering::Relaxed,
        );
    }
}

fn main() {
    let state = Arc::new(TradingState::new());
    let mut alert_manager = AlertManager::new();

    // –ü—Ä–∞–≤–∏–ª–æ: –ë–æ–ª—å—à–∏–µ —É–±—ã—Ç–∫–∏
    let state_clone = Arc::clone(&state);
    alert_manager.add_rule(AlertRule::new(
        "large_loss",
        AlertSeverity::Critical,
        Duration::from_secs(60),
        move || {
            let pnl = state_clone.get_pnl();
            if pnl < -5000.0 {
                Some(format!("Daily P&L: ${:.2}", pnl))
            } else {
                None
            }
        },
    ));

    // –ü—Ä–∞–≤–∏–ª–æ: –°–µ—Ä–∏—è —É–±—ã—Ç–æ—á–Ω—ã—Ö —Å–¥–µ–ª–æ–∫
    let state_clone = Arc::clone(&state);
    alert_manager.add_rule(AlertRule::new(
        "consecutive_losses",
        AlertSeverity::Warning,
        Duration::from_secs(30),
        move || {
            let losses = state_clone.consecutive_losses.load(Ordering::Relaxed);
            if losses >= 5 {
                Some(format!("{} consecutive losing trades", losses))
            } else {
                None
            }
        },
    ));

    // –ü—Ä–∞–≤–∏–ª–æ: –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è –ø–æ–∑–∏—Ü–∏—è
    let state_clone = Arc::clone(&state);
    alert_manager.add_rule(AlertRule::new(
        "large_position",
        AlertSeverity::Warning,
        Duration::from_secs(60),
        move || {
            let position = state_clone.get_position();
            if position > 10.0 {
                Some(format!("Position size: {:.2} BTC", position))
            } else {
                None
            }
        },
    ));

    println!("=== Alert System Demo ===\n");

    // –°–∏–º—É–ª—è—Ü–∏—è: –≤—Å—ë –Ω–æ—Ä–º–∞–ª—å–Ω–æ
    state.set_pnl(1500.0);
    state.set_position(2.5);
    state.heartbeat();
    println!("State: P&L=$1500, Position=2.5 BTC");
    let alerts = alert_manager.check_all();
    if alerts.is_empty() {
        println!("No alerts triggered\n");
    }

    // –°–∏–º—É–ª—è—Ü–∏—è: —Å–µ—Ä–∏—è —É–±—ã—Ç–∫–æ–≤
    println!("Simulating 5 consecutive losses...");
    for _ in 0..5 {
        state.add_loss();
    }
    alert_manager.check_all();

    // –°–∏–º—É–ª—è—Ü–∏—è: –±–æ–ª—å—à–æ–π —É–±—ã—Ç–æ–∫
    println!("\nSimulating large loss...");
    state.set_pnl(-6000.0);
    alert_manager.check_all();

    // –°–∏–º—É–ª—è—Ü–∏—è: –±–æ–ª—å—à–∞—è –ø–æ–∑–∏—Ü–∏—è
    println!("\nSimulating large position...");
    state.set_position(15.0);
    alert_manager.check_all();
}
```

## –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞

```rust
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};

/// –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞
pub struct TradingMonitor {
    // –ú–µ—Ç—Ä–∏–∫–∏
    orders_total: AtomicU64,
    orders_filled: AtomicU64,
    orders_rejected: AtomicU64,
    total_pnl_cents: AtomicU64,  // –°–º–µ—â—ë–Ω–Ω—ã–π –¥–ª—è –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö

    // –ó–¥–æ—Ä–æ–≤—å–µ
    is_connected: AtomicBool,
    last_heartbeat: AtomicU64,

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    order_latency_sum_us: AtomicU64,
    order_latency_count: AtomicU64,

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    start_time: Instant,
}

impl TradingMonitor {
    pub fn new() -> Self {
        TradingMonitor {
            orders_total: AtomicU64::new(0),
            orders_filled: AtomicU64::new(0),
            orders_rejected: AtomicU64::new(0),
            total_pnl_cents: AtomicU64::new(1_000_000_00),
            is_connected: AtomicBool::new(true),
            last_heartbeat: AtomicU64::new(Self::current_timestamp()),
            order_latency_sum_us: AtomicU64::new(0),
            order_latency_count: AtomicU64::new(0),
            start_time: Instant::now(),
        }
    }

    fn current_timestamp() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
    }

    pub fn record_order(&self) {
        self.orders_total.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_fill(&self, latency: Duration, pnl: f64) {
        self.orders_filled.fetch_add(1, Ordering::Relaxed);

        let latency_us = latency.as_micros() as u64;
        self.order_latency_sum_us.fetch_add(latency_us, Ordering::Relaxed);
        self.order_latency_count.fetch_add(1, Ordering::Relaxed);

        // –û–±–Ω–æ–≤–ª—è–µ–º P&L
        let pnl_cents = (pnl * 100.0) as i64;
        if pnl_cents >= 0 {
            self.total_pnl_cents.fetch_add(pnl_cents as u64, Ordering::Relaxed);
        } else {
            self.total_pnl_cents.fetch_sub((-pnl_cents) as u64, Ordering::Relaxed);
        }
    }

    pub fn record_rejection(&self) {
        self.orders_rejected.fetch_add(1, Ordering::Relaxed);
    }

    pub fn heartbeat(&self) {
        self.last_heartbeat.store(Self::current_timestamp(), Ordering::Relaxed);
        self.is_connected.store(true, Ordering::Relaxed);
    }

    pub fn disconnect(&self) {
        self.is_connected.store(false, Ordering::Relaxed);
    }

    pub fn get_pnl(&self) -> f64 {
        let cents = self.total_pnl_cents.load(Ordering::Relaxed);
        (cents as f64 / 100.0) - 1_000_000.0
    }

    pub fn get_fill_rate(&self) -> f64 {
        let total = self.orders_total.load(Ordering::Relaxed);
        let filled = self.orders_filled.load(Ordering::Relaxed);
        if total == 0 {
            return 0.0;
        }
        (filled as f64 / total as f64) * 100.0
    }

    pub fn get_avg_latency(&self) -> Option<Duration> {
        let count = self.order_latency_count.load(Ordering::Relaxed);
        if count == 0 {
            return None;
        }
        let sum = self.order_latency_sum_us.load(Ordering::Relaxed);
        Some(Duration::from_micros(sum / count))
    }

    pub fn is_healthy(&self) -> bool {
        let connected = self.is_connected.load(Ordering::Relaxed);
        let last_hb = self.last_heartbeat.load(Ordering::Relaxed);
        let now = Self::current_timestamp();

        connected && (now - last_hb) < 30
    }

    pub fn uptime(&self) -> Duration {
        self.start_time.elapsed()
    }

    /// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á—ë—Ç–∞ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞
    pub fn dashboard_report(&self) -> String {
        let mut report = String::new();

        report.push_str("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
        report.push_str("‚ïë     TRADING BOT MONITOR DASHBOARD    ‚ïë\n");
        report.push_str("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");

        // –°—Ç–∞—Ç—É—Å
        let status = if self.is_healthy() { "üü¢ HEALTHY" } else { "üî¥ UNHEALTHY" };
        report.push_str(&format!("‚ïë Status: {:27} ‚ïë\n", status));

        // –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã
        let uptime = self.uptime();
        let hours = uptime.as_secs() / 3600;
        let minutes = (uptime.as_secs() % 3600) / 60;
        report.push_str(&format!("‚ïë Uptime: {:02}h {:02}m {:23} ‚ïë\n", hours, minutes, ""));

        report.push_str("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");

        // –û—Ä–¥–µ—Ä–∞
        let total = self.orders_total.load(Ordering::Relaxed);
        let filled = self.orders_filled.load(Ordering::Relaxed);
        let rejected = self.orders_rejected.load(Ordering::Relaxed);
        report.push_str(&format!("‚ïë Orders: {} total, {} filled, {} rej  ‚ïë\n",
            total, filled, rejected));
        report.push_str(&format!("‚ïë Fill Rate: {:6.2}% {:19} ‚ïë\n",
            self.get_fill_rate(), ""));

        // –ó–∞–¥–µ—Ä–∂–∫–∞
        if let Some(latency) = self.get_avg_latency() {
            report.push_str(&format!("‚ïë Avg Latency: {:6.2}ms {:15} ‚ïë\n",
                latency.as_secs_f64() * 1000.0, ""));
        }

        report.push_str("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");

        // P&L
        let pnl = self.get_pnl();
        let pnl_indicator = if pnl >= 0.0 { "üìà" } else { "üìâ" };
        report.push_str(&format!("‚ïë {} P&L: ${:>10.2} {:15} ‚ïë\n",
            pnl_indicator, pnl, ""));

        report.push_str("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");

        report
    }

    /// –≠–∫—Å–ø–æ—Ä—Ç –º–µ—Ç—Ä–∏–∫ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Prometheus
    pub fn prometheus_export(&self) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "# TYPE trading_orders_total counter\ntrading_orders_total {}\n",
            self.orders_total.load(Ordering::Relaxed)
        ));

        output.push_str(&format!(
            "# TYPE trading_orders_filled counter\ntrading_orders_filled {}\n",
            self.orders_filled.load(Ordering::Relaxed)
        ));

        output.push_str(&format!(
            "# TYPE trading_orders_rejected counter\ntrading_orders_rejected {}\n",
            self.orders_rejected.load(Ordering::Relaxed)
        ));

        output.push_str(&format!(
            "# TYPE trading_pnl_dollars gauge\ntrading_pnl_dollars {:.2}\n",
            self.get_pnl()
        ));

        output.push_str(&format!(
            "# TYPE trading_connected gauge\ntrading_connected {}\n",
            if self.is_connected.load(Ordering::Relaxed) { 1 } else { 0 }
        ));

        if let Some(latency) = self.get_avg_latency() {
            output.push_str(&format!(
                "# TYPE trading_order_latency_ms gauge\ntrading_order_latency_ms {:.2}\n",
                latency.as_secs_f64() * 1000.0
            ));
        }

        output.push_str(&format!(
            "# TYPE trading_uptime_seconds gauge\ntrading_uptime_seconds {}\n",
            self.uptime().as_secs()
        ));

        output
    }
}

fn main() {
    let monitor = Arc::new(TradingMonitor::new());

    println!("=== Trading Monitor Demo ===\n");

    // –°–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    for i in 0..100 {
        monitor.record_order();
        monitor.heartbeat();

        if i % 10 == 9 {
            // 10% –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π
            monitor.record_rejection();
        } else {
            // 90% –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–π
            let latency = Duration::from_millis(30 + (i % 50) as u64);
            let pnl = if i % 3 == 0 { -10.0 } else { 15.0 };
            monitor.record_fill(latency, pnl);
        }
    }

    // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–∞—à–±–æ—Ä–¥–∞
    println!("{}", monitor.dashboard_report());

    // Prometheus –º–µ—Ç—Ä–∏–∫–∏
    println!("\n=== Prometheus Metrics ===\n");
    println!("{}", monitor.prometheus_export());
}
```

## –ß—Ç–æ –º—ã —É–∑–Ω–∞–ª–∏

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –û–ø–∏—Å–∞–Ω–∏–µ |
|-----------|----------|
| **Counter** | –°—á—ë—Ç—á–∏–∫, –∫–æ—Ç–æ—Ä—ã–π —Ç–æ–ª—å–∫–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è (–æ—Ä–¥–µ—Ä–∞, –æ—à–∏–±–∫–∏) |
| **Gauge** | –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (–±–∞–ª–∞–Ω—Å, –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏) |
| **Histogram** | –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π (–∑–∞–¥–µ—Ä–∂–∫–∏ –æ—Ä–¥–µ—Ä–æ–≤) |
| **Health Check** | –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã |
| **Alerting** | –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–∏ –ø–æ—Ä–æ–≥–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π |
| **Structured Logging** | –õ–æ–≥–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ |
| **Prometheus** | –°—Ç–∞–Ω–¥–∞—Ä—Ç —ç–∫—Å–ø–æ—Ä—Ç–∞ –º–µ—Ç—Ä–∏–∫ –¥–ª—è —Å–∏—Å—Ç–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ |

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è

1. **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π**: –°–æ–∑–¥–∞–π —Å–∏—Å—Ç–µ–º—É, –∫–æ—Ç–æ—Ä–∞—è:
   - –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –∫ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –±–∏—Ä–∂–∞–º
   - –ò–∑–º–µ—Ä—è–µ—Ç –∑–∞–¥–µ—Ä–∂–∫—É –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Å–≤—è–∑–∏
   - –ê–ª–µ—Ä—Ç–∏—Ç –ø—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω—ã—Ö –æ—Ç–∫–ª—é—á–µ–Ω–∏—è—Ö

2. **–¢—Ä–µ–π—Å–∏–Ω–≥ –æ—Ä–¥–µ—Ä–æ–≤**: –†–µ–∞–ª–∏–∑—É–π —Å–∏—Å—Ç–µ–º—É:
   - –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –ø–æ–ª–Ω—ã–π –∂–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª –æ—Ä–¥–µ—Ä–∞
   - –ò–∑–º–µ—Ä—è–µ—Ç –≤—Ä–µ–º—è –∫–∞–∂–¥–æ–≥–æ —ç—Ç–∞–ø–∞ (—Å–æ–∑–¥–∞–Ω–∏–µ ‚Üí –æ—Ç–ø—Ä–∞–≤–∫–∞ ‚Üí –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ ‚Üí –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ)
   - –í—ã—è–≤–ª—è–µ—Ç —É–∑–∫–∏–µ –º–µ—Å—Ç–∞
   - –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç—á—ë—Ç—ã –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

3. **–ê–Ω–æ–º–∞–ª–∏–∏ –≤ —Ç–æ—Ä–≥–æ–≤–ª–µ**: –°–æ–∑–¥–∞–π –¥–µ—Ç–µ–∫—Ç–æ—Ä:
   - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –Ω–µ–æ–±—ã—á–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã (–º–Ω–æ–≥–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π, –≤—ã—Å–æ–∫–∏–µ –∑–∞–¥–µ—Ä–∂–∫–∏)
   - –°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç —Ç–µ–∫—É—â–∏–µ –º–µ—Ç—Ä–∏–∫–∏ —Å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–º–∏
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–Ω–∏–∂–∞–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø—Ä–∏ –∞–Ω–æ–º–∞–ª–∏—è—Ö
   - –õ–æ–≥–∏—Ä—É–µ—Ç –≤—Å–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

4. **–î–∞—à–±–æ—Ä–¥ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏**: –†–µ–∞–ª–∏–∑—É–π:
   - –í–µ–±-—Å–µ—Ä–≤–µ—Ä —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
   - –ì—Ä–∞—Ñ–∏–∫–∏ P&L, –æ—Ä–¥–µ—Ä–æ–≤, –∑–∞–¥–µ—Ä–∂–µ–∫
   - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å Grafana —á–µ—Ä–µ–∑ Prometheus
   - –ê–ª–µ—Ä—Ç—ã –≤ Telegram/Slack

## –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ

1. **–ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞**: –†–∞–∑—Ä–∞–±–æ—Ç–∞–π —Å–∏—Å—Ç–µ–º—É:
   - –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ –º–µ—Ç—Ä–∏–∫–∏ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞
   - –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –≤ Prometheus
   - –ò–º–µ–µ—Ç Health endpoint –¥–ª—è Kubernetes
   - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç graceful shutdown
   - –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏—Å—Ç–æ—Ä–∏—é –º–µ—Ç—Ä–∏–∫

2. **–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∞–ª–µ—Ä—Ç–∏–Ω–≥**: –°–æ–∑–¥–∞–π —Å–∏—Å—Ç–µ–º—É:
   - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –±–∞–∑–æ–≤—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
   - –ê–¥–∞–ø—Ç–∏—Ä—É–µ—Ç –ø–æ—Ä–æ–≥–∏ –∫ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫ –∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
   - –ì—Ä—É–ø–ø–∏—Ä—É–µ—Ç –ø–æ—Ö–æ–∂–∏–µ –∞–ª–µ—Ä—Ç—ã
   - –≠—Å–∫–∞–ª–∏—Ä—É–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã
   - –í–µ–¥—ë—Ç –∏—Å—Ç–æ—Ä–∏—é –∏–Ω—Ü–∏–¥–µ–Ω—Ç–æ–≤

3. **–†–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–∞—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞**: –†–µ–∞–ª–∏–∑—É–π:
   - –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ —á–µ—Ä–µ–∑ –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
   - Correlation ID –¥–ª—è —Å–≤—è–∑–∏ —Å–æ–±—ã—Ç–∏–π
   - –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –ø–æ—Ç–æ–∫–∞ –¥–∞–Ω–Ω—ã—Ö
   - –ê–Ω–∞–ª–∏–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
   - –ü–æ–∏—Å–∫ bottlenecks

4. **Chaos Engineering –¥–ª—è —Ç—Ä–µ–π–¥–∏–Ω–≥–∞**: –°–æ–∑–¥–∞–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç:
   - –°–∏–º—É–ª–∏—Ä—É–µ—Ç —Å–±–æ–∏ (–æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –±–∏—Ä–∂–∏, –∑–∞–¥–µ—Ä–∂–∫–∏ —Å–µ—Ç–∏)
   - –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –ø—Ä–∏ —Å–±–æ—è—Ö
   - –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç –∞–ª–µ—Ä—Ç—ã –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
   - –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç—á—ë—Ç—ã –æ –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏
   - –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç —É–ª—É—á—à–µ–Ω–∏—è

## –ù–∞–≤–∏–≥–∞—Ü–∏—è

[‚Üê –ü—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å](../326-async-vs-threading/ru.md) | [–°–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å ‚Üí](../354-*/ru.md)
